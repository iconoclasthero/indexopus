#!/bin/bash
# depends: opustags, ffmpeg/ffprobe, mediainfo
# config: "$HOME/.config/indexopus.conf"
#          absserver="https://web.address.com"
#          abssqlite="/path/to/location/of/config/absdatabase.sqlite"
# files must be in the format of Title -- Part ##: Chapter Title.opus and present ONLY works for .opus; there are other tools for e.g., m4b: use them.
# presumably, this script could easily be changed out for another codec, however opustags would need to change to something else that can write metadata, e.g, ffmpeg which should be able to do any format.
# that said, the author feels that this satisfices for the purposes at hand and if/when the codec changes, that bridge will be burnt when it is arrived upon.
# Would like to make it so that the files do not need a chapter name and are iterated with 000, 001, 002, .... for Chapter Title
# ffmpeg could presumably take over for opustags to eliminate that dependency and then all that would be required is ffmpeg
# Also, given that tagging is being done, it might be useful to tag at least the tracknumber and the track title in this script rather than doing it after.
#
# Promlem with colons in the part description:
# That could still indicate a problem if the code is later attempting to do shell arithmetic on the value, in which case you got lucky by having printf throw an error. You could fix that by adding a test and failing early, because printf won't cause the script to exit.
# https://mywiki.wooledge.org/BashFAQ/054 -- How can I tell whether a variable contains a valid number?


shopt -s extglob nullglob dotglob
scriptpath=$(realpath "$0")
confpath="$HOME/.config/indexopus.conf"
. "$confpath"
ulon="$(tput smul)"  #underline on
uloff="$(tput rmul)" #underline off
red="$(tput setaf 9)" #red fg
white="$(tput setaf 15)" #white fg
tput0="$(tput sgr0)" #reset tput changes
bold="$(tput bold)" #bold on
relipsis="$red..."
stamp="$(date +%s)"  #sets datecode for all of indexopus - could use info from m4b2opus later
tmp="/tmp/indexopus-$stamp" #this could change based on info from m4b2opus

editscript(){
  local script path; script="${scriptpath##*/}"; path="${scriptpath%/*}"; swp="$path/.$script.swp"
     if [[ ! -e "$swp" ]]; then printf "\n\n%s\n\n" "$swp"; (/usr/bin/nano "$scriptpath"); exit
     else printf "\n%s is already being edited.\n%s exists; try fg or look in another window.\n" "$scriptpath" "$swp"; exit;
  fi; }
##--> editscript() <--#################################################################################

pause(){ read -p "$*" ; }
##--> pause() <--######################################################################################

confirm(){
 local ans IFS=
 while read -rp "$1" -n1 ans
   do
     printf '\n'
     case "$ans" in
       [Yy]) return 0;;
       [Nn]) return 1;;
     esac
   done
}
##--> confirm() <--###################################################################################

#unused
tagtt(){
for i in *\ --\ Part\ ??\:\ *opus
 do
   title="${i%.opus}"
   title="${title#* -- }"
   tracknumber="${i%:*}"
   tracknumber="${tracknumber#*Part }"
   opustags -i "$i" -s title="$title" -s tracknumber="$tracknumber"
done
}
##--> tagtt() <--######################################################################################


rmyn(){
  while true
  read -rp "$1" rmyn
   do
     case "$rmyn" in
       [yY] ) "${@:3}"; rmynres=0; break;;
       [nN] ) printf '\n%s\n' "$2"; rmynres=1; break;;
          * ) printf "Invalid response...\n";;
     esac
   done
}
##--> rmyn() <--#######################################################################################

yn(){
  while true
  read -p "$1" yn
   do
     case "$yn" in
       [yY] ) "$2"; break;;
       [nN] ) "$3"; break;;
          * ) printf "Invalid response...\n";;
     esac
   done
}
##--> yn() <--#########################################################################################


is_even() {
    if [ $(( $1 % 2 )) -eq 0 ]; then return 0
    else return 1; fi
}
##--> is_even() <--####################################################################################

gettitle(){
titles=(*Part\ ??*.opus)
ext="${titles[0]##*.}"
[[ ! -n "$title" ]] && title="${titles[0]% -- Part*}"
ititle="${ulon}$title${uloff}"
output="$title -- Audiobook.opus"
ioutput="$ititle -- Audiobook.opus"
}
##--> gettitle() <--###################################################################################

createindex(){
chno=0
for i in "$title -- Part "*.opus
 do
   chna="${i#* -- Part }"; chna="${chna%.opus}"; chna="${chna#*: }"
   if [[ "$t" != 0 ]]
    then
      ts=$(echo "$t" | perl -nle '/([0-9\.]+)/ && ($t +=$1) && printf "%02d:%02d:%06.03f\n", $t/3600, $t/60%60, $t%60 + $t-int($t)' | tail -n 1)
      printf 'CHAPTER%03d=%s\n' "$chno" "$ts" >>  "$tmp/opusindex"
      printf 'CHAPTER%03dNAME=%s\n' "$chno" "$chna" >>  "$tmp/opusindex"
      createdindex+=( "$i" )
      createdindex+=( "$(printf 'CHAPTER%03d=%s' "$chno" "$ts")" )
      createdindex+=( "$(printf 'CHAPTER%03dNAME=%s' "$chno" "$chna")" )
    else
      ts="00:00:00.000"
      printf 'CHAPTER%03d=%s\n' "$chno" "$ts" >> "$tmp/opusindex"
      printf 'CHAPTER%03dNAME=%s\n' "$chno" "$chna" >>  "$tmp/opusindex"
#pause "$i"
      createdindex+=( "$i" )
      createdindex+=( "$(printf 'CHAPTER%03d=%s' "$chno" "$ts")" )
      createdindex+=( "$(printf 'CHAPTER%03dNAME=%s' "$chno" "$chna")" )
   fi
      d=$(ffprobe -v error -show_entries format=duration -of default=nk=1:nw=1 "$i")
#      d=$(mplayer -vo dummy -ao dummy -identify "$i" 2>/dev/null | perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "$t"' | tail -n 1)
      t=$(echo "$d + $t" | bc)
      ((chno++))
done

#check index for single quotes:
for f in @("$title -- Part "??\:\ *.opus|"$title -- Part "???\:\ *.opus)
 do
   if [[ "$PWD/$f" == *\'* ]]
    then
       ff="$f"; dir="$PWD"
       [[ "$f" == *\'* ]] && ff="${f//\'/\'\\\'\'}" || ff="$f"  #ffmpeg will not take filenames with ' in them, they must be quoted:
       [[ "$PWD" = *\'* ]] && dir="${PWD//\'/\'\\\'\'}"
       echo "file '$dir/$ff'" >> "$tmp/opusfiles"
    else
       echo "file '$PWD/$f'" >> "$tmp/opusfiles"
    fi
done

}
##--> createindex() <--################################################################################


reindex(){
local t chap_title chap_starts reintitle
t=0
chno=0

readarray -t chap_titles < <(jq -r '.chapters[] | .title' metadata.json 2>/dev/null)
readarray -t chap_starts < <(jq -r '.chapters[] | .start' metadata.json 2>/dev/null)

[[ ! "${chap_titles[@]}" ]] || [[ ! "${chap_starts[@]}" ]] &&
   printf 'Error with %s/metadata.json; check and retry.\nexit 1' "$PWD" &&
   exit 1

reintitle=( *\ --\ Audiobook.opus )

[[ ! "${#reintitle[@]}" -eq 1 ]] && printf 'No suitable audiobook found in pwd of format * -- Audiobook.opus\nCheck path %s and try again.\nexit 1' "$PWD" && exit 1

for ((chno=0;chno<"${#chap_titles[@]}";chno++))
 do
   t="${chap_starts[$chno]}"
   if [[ "$t" != 0 ]]
    then
      ts=$(echo "$t" | perl -nle '/([0-9\.]+)/ && ($t +=$1) && printf "%02d:%02d:%06.03f\n", $t/3600, $t/60%60, $t%60 + $t-int($t)' | tail -n 1)
      chna="${chap_titles[$chno]}"
      [[ "$chna" = *@(Part|Chapter)\ ? ]] && chna="${chna/ / 0}"
      printf 'CHAPTER%03d=%s\n' "$chno" "$ts" >>  "$tmp/opusindex"
      printf 'CHAPTER%03dNAME=%s\n' "$chno" "$chna" >>  "$tmp/opusindex"
      rawindex+=( "$ts" )
      rawindex+=( "$chna" )
      createdindex+=( "$(printf 'CHAPTER%03dNAME=%s' "$chno" "$chna")" )
      createdindex+=( "$chno" )
      createdindex+=( "$(printf 'CHAPTER%03d=%s' "$chno" "$ts")" )
      createdindex+=( "$(printf 'CHAPTER%03dNAME=%s' "$chno" "$chna")" )
    else
      ts="00:00:00.000"
      chna="${chap_titles[$chno]}"
      [[ "$chna" = *@(Part|Chapter)\ ? ]] && chna="${chna/ / 0}"
      printf 'CHAPTER%03d=%s\n' "$chno" "$ts" >> "$tmp/opusindex"
      printf 'CHAPTER%03dNAME=%s\n' "$chno" "$chna" >>  "$tmp/opusindex"
      rawindex+=( "$ts" )
      rawindex+=( "$chna" )
      createdindex+=( "$chno" )
      createdindex+=( "$(printf 'CHAPTER%03d=%s' "$chno" "$ts")" )
      createdindex+=( "$(printf 'CHAPTER%03dNAME=%s' "$chno" "$chna")" )
   fi
done

#cat "$tmp/opusindex"
mediainfo "$reintitle"
printf '%s%sProposed index for %s:%s\n' "$red" "$bold" "$reintitle" "${tput0}"
printf "$bold"
printf '%s\t\t\t\t : %s\n' "${rawindex[@]}"
#pause
#printf '%s                             : %s\n' "${rawindex[@]}"
sqlitepwd="${PWD//\'/\'\'}"
itemid="$(sqlite3 "$abssqlite" "select id FROM libraryitems WHERE path=='$sqlitepwd';" ".exit")"
printf '%s\n%sThe index was generated from existing metadata.json;\n' "$tput0" "$red"
[[ "$itemid" ]] && printf 'look up new chapter information at\ngoogle-chrome %s/audiobook/%s/chapters\n\n\n' "$absserver" "$itemid"
[[ ! "$itemid" ]] && printf '%s%s not found in absdatabase.sqlite!%s\n%sCheck path and metadata.json file\n\n\n' "$bold" "$PWD" "$tput0" "$red"

if [[ "$rmmatch" = true ]]
  then
   writeindex "$reintitle"
elif confirm "${bold}${red}Apply index? ${tput0}"
  then
   writeindex "$reintitle"
   rmmatch=true  #at this point, having said yes to apply index, yes the rest of the way.
else
   mediainfo "$reintitle"
   printf '%s\t\t\t\t : %s\n' "${rawindex[@]}"
   printf 'Not reindexing opus file with above index; exiting.'
   exit
fi

mediainfo *Audiobook.opus

rm -rf "$tmp"
#probably no longer need to preserve the temp files.  they're mostly only necessary for debugging.
#if [[ -d "$tmp" ]] && [[ "$rmmatch" = true ]]
#  then
#    rm  -rf "$tmp"
#    ls "$tmp" 2>/dev/null
##    rm *Part\ ??\:\ *.opus 2>/dev/null #probably don't need/want this here!
#elif [[ -d "$tmp" ]]
#  then
#    echo "Contents of $tmp"
#    ls "$tmp" 2>/dev/null
#    echo
#    rmyn "${red}${bold}Remove temporary files? (y/n) ${tput0}" "Leaving temporary files in $tmp" rm -rf "$tmp" *Part\ ??\:\ *.opus
#
#fi

}
##reindex()####################################################################################

writeindex(){
local writetitle="$1"

if [[ "$(opustags "$writetitle")" = *CHAPTER* ]]
  then
    opustags -d "OverDrive MediaMarkers" -i "$writetitle"
    printf '\n%s%s%s contains existing tags; removing...%s\n' "$relipsis" "$bold" "$title" "$tput0"
    tags=( $(opustags "$writetitle") )
    tags=( $(printf -- '-d%s\n' "${tags[@]%=*}"|\grep CHAPTER|sort -u) )
    printf '\n%smediainfo of existing %s:%s\n' "$relipsis" "$writetitle" "$tput0"
    mediainfo "$writetitle"
    printf '\n%sremoving exiting CHAPTER tags with opustags...%s\n\n' "$relipsis" "$tput0"
    opustags "${tags[@]}" -i "$writetitle"
    ck4tags=( "$(opustags "$writetitle" | grep --color=always -i chapter)" ) &&
      printf 'Error!\nCHAPTER tags still present in opus file.\n%s' "${ck4tags[@]}" &&
      exit
  else
    printf '%smediainfo of existing %s:%s\n' "$relipsis" "$writetitle" "$tput0"
    mediainfo "$writetitle"
fi

while read -r chaptag
 do
   args+=(-a "$chaptag")
 done < "$tmp/opusindex"

opustags -i "$writetitle" "${args[@]}"
printf '%sChapter info added...\n\n%s' "$relipsis" "$tput0"

}
##--> writeindex() <--#################################################################################



##--> Main Code <--####################################################################################
##--> indexopus <--####################################################################################

[[ "$1" = @(edit|e|nano) ]] && editscript

#better option handling needed
[[ "$1" = "-y" ]] && shift && rmmatch=true    # this is to conrirm removal of temp files upon time match...and other stuff
[[ "$1" = "reindex" ]] && shift && reindex=true  # this is when in the directory of `* Audiobook.opus; metadata.json` from audiobookshelf.

mkdir "$tmp" || printf '%s%sFailed to create %s!\nexit 1\n%s' "$red" "$bold" "$tmp" "$tput0" #&& exit

if [[ "$reindex" = true ]]   #if reindex is true, check for rmmatch and reindex.
 then
   [[ "$1" = "-y" ]] && shift && rmmatch=true
   reindex
   printf '%sPlease see %s/%s for indexed file.%s\n\n' "$red" "$PWD" "$reintitle" "$tput0"
   exit
fi

# this checks for a metadata.json, ideally from audiobookshelf.  there could be other metadata.json files
# abs doesn't support json files with other names, nor is there anything in the json identifying it
# as an abs file.  It does check the .json for the chapter index, so there's at least that...
if [[ -f metadata.json ]] && [[ "$(jq -r '.chapters[0].title' metadata.json)" ]]
  then
    reindex=true
    ckjson=( *opus )
    [[ "$(jq -r '.chapters[0] | .title' metadata.json)".opus == "${ckjson[0]}" ]] ||
      [[ "$(jq -r '.chapters[0] | .title' metadata.json)" == "001" ]] &&
      reindex=false
    [[ "$reindex" = false ]] &&
      printf '%sA metadata.json file exists with duplicate chapter information; look up new chapter information at\ngoogle-chrome %s%s/chapters\n\n' "$red" "$absserver" "$(sqlite3 "$abssqlite" "select id FROM libraryitems WHERE path=='$PWD';" ".exit")" &&
      confirm "${bold}Would you like to try to reindex the file after importing chapter information?${tput0}" &&
      reindex=true
fi

if ! compgen -G @(*\ --\ Part\ ???\:\ *.opus|*\ --\ Part\ ??\:\ *.opus) &> /dev/null
 then
   if compgen -G @(*\ --\ Chapter\ ??*.opus|*\ --\ Disc\ ??.opus|*-Part??.opus) &> /dev/null
     then
       for renopus in *Chapter\ ??*.opus; do [[ -f "$renopus" ]] && mv "$renopus" "${renopus/ Chapter / Part }"; done
       for renopus in *Disc\ ??.opus; do [[ -f "$renopus" ]] && mv "$renopus" "${renopus/ Disc / Part }"; done
       for renopus in *-Part??.opus; do [[ -f "$renopus" ]] && mv "$renopus" "${renopus/-Part/ -- Part 00: Part }"; done
   fi

   renopus=( *\ --\ Part\ *.opus )

#  if [[ "${renopus[0]}" != @(*\ --\ Part\ ???\:\ *.opus|*\ --\ Part\ ??\:\ *.opus) ]]
   if ! compgen -G @(*\ --\ Part\ ???\:\ *.opus|*\ --\ Part\ ??\:\ *.opus) &> /dev/null
     then
       if [[ "${renopus[0]/ -- Part / -- Part 00: Part }" == *\ --\ Part\ ??\:\ *.opus ]]
         then
           for i in *opus
             do
               n="${i#* -- Part }"; n="${n%%.opus}"
               mv "$i" "${i/ -- Part / -- Part $n: Part }"
             done
         else
           printf 'This directory does not contain files in the format of %s<Title>%s -- Part ##:<Chapter Title>.opus\nPlease check the directory this script was launched from to make sure it contains the proper files.\n' "${ulon}" "${uloff}"
           exit
       fi
   fi
fi

#ffprobe -sexagesimal -> "00:00:00.00"
d=0
t=0

[[ -n "$1" ]] && [[ "$1" != -y ]] && title="$1"

gettitle "$title"

echo "$title"

if [[ -f ./"$output" ]] && [[ "$rmmatch" != true ]]
 then
   printf 'This directory already contains %s\n' "$ioutput"
   if confirm "Overwrite the existing file? (y/n) "
    then
      printf '\n...Overwriting %s -- Audiobook.opus...\n' "$ititle"
    else
      [[ -f metadata.json ]] &&
        confirm "$(printf '\nNot overwriting.\nA metadata.json file was found. Would you like to reindex the file?')" &&
        reindex=true && overwrite=false ||
        exit
   fi
fi


[[ "$2" ]] && duration="$2" ||
           duration=$(find . -type f \( -iname "$title -- Part ??:*.opus" -o -iname "$title -- Part ???:*.opus" \) -print0 |
           xargs -0 mplayer -vo dummy -ao dummy -identify 2>/dev/null |
           perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "%02d:%02d:%02d\n",$t/3600,$t/60%60,$t%60' |
           tail -n 1)

printf '\n%sGenerating the index for %s -- Audiobook.opus from...%s\n\n' "$relipsis" "$ititle" "$tput0"

createindex
printf '%s:~%s~%s\n\n' "${createdindex[@]}"|paste|column -t -s "~"
printf '\n%sConcatenating %s -- Part ??: *.opus...%s\n\n' "$relipsis" "$ititle" "$tput0"

#concatination step:
dirsize="$(du -csb *Part*opus|tail -n1)"
dirsize="${dirsize%%$'\t'*}" #remove everything after first tab stop
dirsize="$((dirsize/1000))" #convert bytes to KiB
printf '%sparts= %sKiB time=%s%s\n' "$red" "$dirsize" "$duration" "$tput0"
[[ "$overwrite" != false ]] && ffmpeg -nostdin -hide_banner -v error -stats -f concat -safe 0 -thread_queue_size 1024 -i "$tmp/opusfiles" -n -acodec copy "/tmp/$output"
[[ "$overwrite" != false ]] && [[ "$?" != 0 ]] && echo && echo "ffmpeg failed to concatinate; exit 1" && echo && exit 1

printf '\n\n%sIncorporating index into%s %s -- Audiobook.opus%s\n\n%s' "$relipsis" "$white" "$ititle" "$relipsis" "$tput0"

mv "/tmp/$output" "$output"

#while read -r chaptag
# do
#   args+=(-a "$chaptag")
# done < ""$tmp/opusindex""
#
#opustags -i "$output" "${args[@]}"
#


writeindex "$output"

if [[ -f "$output" ]] && eval command -v mediainfo &> /dev/null
 then
   printf '%sChecking output from mediainfo...\n\n%s' "$relipsis" "$tput0"

   outdur="$(mediainfo -f "$output"|grep Duration|head -n1)"
   outdur="${outdur#*: }"
   outdur="$(echo "$outdur" | perl -nle '/([0-9\.]+)/ && ($t += $1) && printf "%02d:%02d:%02d\n", $t/3600000, ($t/60000)%60, ($t/1000)%60')"

   data=( "${bold}Duration(s):${tput0}"
          "${red}${bold} $duration ${tput0}${ititle} -- Part *opus $tput0"
          "${red}${bold} $outdur ${tput0}${ititle} -- Audiobook.opus $tput0")

   # Print the aligned data using column, right justifying durations
   printf '%s\n' "${data[@]}" #| column -s "~" -t -R 2
   echo "$tput0 $white"
elif [[ -f "$output" ]] && eval command -v ffprobe &> /dev/null
     then
       printf 'Checking the output from ffprobe...\n\n'
       ffprobe "$output"
      printf 'Original duration... %s' "$duration"
   else
     echo "Indexed opus file not found! Exit 1"
     rmyn "remove $tmp? " "leaving files" rm -r "$tmp"
#     (( $rmynres == 1 )) && >&2 echo "$tmp"
     exit 1
fi

[[ "$rmmatch" ]] &&
   [[ "$duration" = "$outdur" ]] &&
   printf 'Durations of part and indexed opus files match, automatically deleting temporary files!\n\n%s%sPlease see %s/%s%s\n\n%sDone.\n\n%s' "$white" "$bold" "$PWD" "$ioutput" "$tput0" "$relipsis" "$tput0" &&
   rm -r "$title"\ --\ Part\ ??:*.opus "$tmp" &&
   exit

[[ "$reindex" = true ]] && confirm "$(printf '%sA metadata.json file was found!\n%sReindex the file with audiobookshelf chapter info?%s' "${red}" "${bold}" "${tput0}")" && indexopus reindex
rmyn "${bold}${red}Remove temporary files? (y/n) ${tput0}" "$bold Leaving temporary files $tput0" rm -r "$title"\ --\ Part\ ??:*.opus "$tmp" && iorm=true
printf '\n\n%s...Done.\n\nPlease see %s/%s\n\n' "$relipsis" "$PWD" "$ioutput"

#exec 5<> "$tmp/5"
(( $rmynres == 1 )) && echo "$tmp remains"

#clean up /tmp/indexopus-* files older than a day:
find /tmp -iname "indexopus-1*" -mtime -1 -exec rm -rf {} 2>/dev/null \;

printf '%s' "$tput0"

[[ "$iorm" = true ]] && exit 2 || exit  # this has to be here so that it is passed back to m4b2opus

exit


