#!/bin/bash
# depends: opustags, ffmpeg/ffprobe, mediainfo
# config: "$HOME/.config/indexopus.conf"
#          absserver="https://web.address.com"
#          abssqlite="/path/to/location/of/config/absdatabase.sqlite"
# files must be in the format of Title -- Part ##: Chapter Title.opus and present ONLY works for .opus; there are other tools for e.g., m4b: use them.
# presumably, this script could easily be changed out for another codec, however opustags would need to change to something else that can write metadata, e.g, ffmpeg which should be able to do any format.
# that said, the author feels that this satisfices for the purposes at hand and if/when the codec changes, that bridge will be burnt when it is arrived upon.
# Would like to make it so that the files do not need a chapter name and are iterated with 000, 001, 002, .... for Chapter Title
# ffmpeg could presumably take over for opustags to eliminate that dependency and then all that would be required is ffmpeg
# Also, given that tagging is being done, it might be useful to tag at least the tracknumber and the track title in this script rather than doing it after.
# ffprobe -sexagesimal -> "00:00:00.00"
#
# Promlem with colons in the part description:
# That could still indicate a problem if the code is later attempting to do shell arithmetic on the value, in which case you got lucky by having printf throw an error. You could fix that by adding a test and failing early, because printf won't cause the script to exit.
# https://mywiki.wooledge.org/BashFAQ/054 -- How can I tell whether a variable contains a valid number?


shopt -s extglob nullglob dotglob
scriptpath=$(realpath "$0")
confpath="$HOME/.config/indexopus.conf"
. "$confpath"                                 #this needs to move.
. "$HOME/bin/gits/indexopus/indexopus.lib"
ulon="$(tput smul)"  #underline on
uloff="$(tput rmul)" #underline off
red="$(tput setaf 9)" #red fg
white="$(tput setaf 15)" #white fg
tput0="$(tput sgr0)" #reset tput changes
bold="$(tput bold)" #bold on
relipsis="$red..."
stamp="$(date +%s)"  #sets datecode for all of indexopus - could use info from m4b2opus later
tmp="/tmp/indexopus-$stamp" #this could change based on info from m4b2opus

editscript(){
  local script path; script="${scriptpath##*/}"; path="${scriptpath%/*}"; swp="$path/.$script.swp"
     if [[ ! -e "$swp" ]]; then printf "\n\n%s\n\n" "$swp"; (/usr/bin/nano "$scriptpath"); exit
     else printf "\n%s is already being edited.\n%s exists; try fg or look in another window.\n" "$scriptpath" "$swp"; exit;
  fi; }
##--> editscript() <--#################################################################################

pause(){ read -p "$*" ; }
##--> pause() <--######################################################################################

usage() {
    echo "Usage: $0 [-e] [-y] [-t <title>] [-s <timestamp>] [-m <temp path>] [-c <config path>] [-r] [-h]"
    echo "Options:"
    echo "  -e, --edit               Call editscript function"
    echo "  -y, -f, --force          Accept all prompts if the times line up"
    echo "  -t, --title <title>      Specify title"
    echo "  -s, --stamp <timestamp>  Specify timestamp"
    echo "  -m, --tmp <temp path>    Specify temporary path"
    echo "  -c, --config <config path> or blank for default location: $HOME/.config/indexopus.conf"
    echo "  -r, --reindex, reindex   Reindex the file"
    echo "  -h, --help               Display this help message"
    exit 1 ; }
##--> usage() <--######################################################################################

confirm(){
 local ans IFS=
 while read -rp "$1" -n1 ans
   do
     printf '\n'
     case "$ans" in
       [Yy]) return 0;;
       [Nn]) return 1;;
     esac
   done
}
##--> confirm() <--###################################################################################

#unused
#tagtt(){
#  for i in *\ --\ Part\ ??\:\ *opus
#    do
#      title="${i%.opus}"
#      title="${title#* -- }"
#      tracknumber="${i%:*}"
#      tracknumber="${tracknumber#*Part }"
#      opustags -i "$i" -s title="$title" -s tracknumber="$tracknumber"
#    done
#}
##--> tagtt() <--######################################################################################


rmyn(){
  while true
  read -rp "$1" rmyn
   do
     case "$rmyn" in
       [yY] ) "${@:3}"; rmynres=0; break;;
       [nN] ) printf '\n%s\n' "$2"; rmynres=1; break;;
          * ) printf "Invalid response...\n";;
     esac
   done
}
##--> rmyn() <--#######################################################################################

#yn(){
#  while true
#  read -p "$1" yn
#   do
#     case "$yn" in
#       [yY] ) "$2"; break;;
#       [nN] ) "$3"; break;;
#          * ) printf "Invalid response...\n";;
#     esac
#   done
#}
##--> yn() <--#########################################################################################


#is_even() {
#    if [ $(( $1 % 2 )) -eq 0 ]; then return 0
#    else return 1; fi
#}
##--> is_even() <--####################################################################################

gettitle(){
[[ ! -n "$title" ]] && titles=(*Part\ ??*.opus) && title="${titles[0]% -- Part*}"
ititle="${ulon}$title${uloff}"
output="$title -- Audiobook.opus"
ioutput="$ititle -- Audiobook.opus"
}
##--> gettitle() <--###################################################################################

createindex(){
  chno=0
  for i in "$title -- Part "*.opus
    do
      chna="${i#* -- Part }"; chna="${chna%.opus}"; chna="${chna#*: }"
      [[ "$chna" = @(Chapter|Part)\ ? || "$chna" = @(Chapter|Part)\ ?\ * ]] && chna="${chna/ / 0}"
      if [[ "$t" != 0 ]]; then
        ts=$(echo "$t" | perl -nle '/([0-9\.]+)/ && ($t +=$1) && printf "%02d:%02d:%06.03f\n", $t/3600, $t/60%60, $t%60 + $t-int($t)' | tail -n 1)
        printf 'CHAPTER%03d=%s\n' "$chno" "$ts" >>  "$tmp/opusindex"
        printf 'CHAPTER%03dNAME=%s\n' "$chno" "$chna" >>  "$tmp/opusindex"
        createdindex+=( "$i" )
        createdindex+=( "$(printf 'CHAPTER%03d=%s' "$chno" "$ts")" )
        createdindex+=( "$(printf 'CHAPTER%03dNAME=%s' "$chno" "$chna")" )
      else
        ts="00:00:00.000"
        printf 'CHAPTER%03d=%s\n' "$chno" "$ts" >> "$tmp/opusindex"
        printf 'CHAPTER%03dNAME=%s\n' "$chno" "$chna" >>  "$tmp/opusindex"
        createdindex+=( "$i" )
        createdindex+=( "$(printf 'CHAPTER%03d=%s' "$chno" "$ts")" )
        createdindex+=( "$(printf 'CHAPTER%03dNAME=%s' "$chno" "$chna")" )
      fi
      d=$(ffprobe -v error -show_entries format=duration -of default=nk=1:nw=1 "$i")
#     d=$(mplayer -vo dummy -ao dummy -identify "$i" 2>/dev/null | perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "$t"' | tail -n 1)
      t=$(echo "$d + $t" | bc)
      ((chno++))
    done

#ffmpeg will not take filenames with ' in them, they must be quoted:
#check index for single quotes:
for f in @("$title -- Part "??\:\ *.opus|"$title -- Part "???\:\ *.opus)
 do
   if [[ "$PWD/$f" == *\'* ]]
    then
       ff="$f"; dir="$PWD"
       [[ "$f" == *\'* ]] && ff="${f//\'/\'\\\'\'}" || ff="$f"
       [[ "$PWD" = *\'* ]] && dir="${PWD//\'/\'\\\'\'}"
       echo "file '$dir/$ff'" >> "$tmp/opusfiles"
    else
       echo "file '$PWD/$f'" >> "$tmp/opusfiles"
    fi
done

}
##--> createindex() <--################################################################################
##
## Need to check metadata.json files to see if the keys match up with the abs pattern...
## Need to check chapter.json files for `{"error":"Chapters not found"}`
##

reindex(){
  local t chap_title chap_starts reintitle
  t=0
  chno=0

  if [[ ! -f "chapters.json" ]]; then
    if confirm "${bold}No chapters.json; retrieve chapter info from the web?${tput0}"; then
#      printf '$s\n%s' 'curl -X POST "$absserver/api/items/$(itemid)/scan"   -H "Authorization: Bearer $abstoken"' $(curl -X POST "$absserver/api/items/$(itemid)/scan"   -H "Authorization: Bearer $abstoken")
#      printf '%s\n%s' $(curl "$absserver/api/search/chapters?asin=$(jq -r '.asin' metadata.json)"   -H "Authorization: Bearer $abstoken" >chapters.json) 'curl "$absserver/api/search/chapters?asin=$(jq -r '.asin' metadata.json)"   -H "Authorization: Bearer $abstoken" >chapters.json'
      curl -X POST "$absserver/api/items/$(itemid)/scan"   -H "Authorization: Bearer $abstoken" -sSo /dev/null
      curl "$absserver/api/search/chapters?asin=$(jq -r '.asin' metadata.json)"   -H "Authorization: Bearer $abstoken" -sSo chapters.json
      newchapters=true
    fi
  fi

  if [[ -f "chapters.json" ]] && [[ ! $(grep '{"error":"Chapters not found"}' "chapters.json") ]]; then
    readarray -t chap_titles < <(jq -r '.chapters[] | .title' "chapters.json" 2>/dev/null)
    readarray -t chap_starts < <(jq -r '.chapters[] | .startOffsetMs' "chapters.json" 2>/dev/null)
#    for ((i=0; i<"${#chap_starts[@]}"; i++));
#      do
#        chap_starts[i]=$(echo $(( chap_starts[i] / 1000 )) )
#      done

#  for ((i=0; i<"${#chap_starts[@]}"; i++)); do
#    seconds=$(echo "scale=3; ${chap_starts[i]} / 1000" | bc)
#    chap_starts[i]=$(echo $seconds | perl -nle '/([0-9\.]+)/ && ($t +=$1) && printf "%02d:%02d:%06.03f\n", $t/3600, $t/60%60, $t%60 + $t-int($t)' | tail -n 1)
#  done

  for ((i=0; i<"${#chap_starts[@]}"; i++)); do
    sec=$(( chap_starts[i] / 1000 ))
    ms=$(( chap_starts[i] % 1000 ))
    chap_starts[i]="${sec}.${ms}"
  done

#    pause "$(printf '%s\n' "${chap_starts[@]}")"
#    pause "$(printf '%s\n' "${chap_titles[@]}")"

  else
    readarray -t chap_titles < <(jq -r '.chapters[] | .title' "metadata.json" 2>/dev/null)
    readarray -t chap_starts < <(jq -r '.chapters[] | .start' "metadata.json" 2>/dev/null)
  fi

#pause $(printf '%s - %s\n' "${chap_titles}" "${chap_titles}")

 [[ ! "${chap_titles[@]}" ]] || [[ ! "${chap_starts[@]}" ]] &&
    printf 'Error with %s/metadata.json; check and retry.\nexit 1' "$PWD" &&
    exit 1

  reintitle=( *\ --\ Audiobook.opus )

  [[ ! "${#reintitle[@]}" -eq 1 ]] && printf 'No suitable audiobook found in pwd of format * -- Audiobook.opus\nCheck path %s and try again.\nexit 1' "$PWD" && exit 1

  for ((chno=0;chno<"${#chap_titles[@]}";chno++))
    do
      t="${chap_starts[$chno]}"
#      pause "${chap_starts[0]} $t"
      if [[ "$t" != @(0|0.0) ]]; then
        ts=$(echo "$t" | perl -nle '/([0-9\.]+)/ && ($t +=$1) && printf "%02d:%02d:%06.03f\n", int($t / 3600), int($t / 60) % 60, $t % 60 + ($t - int($t))' | tail -n 1)
        chna="${chap_titles[$chno]}"
        [[ "$chna" = *@(Part|Chapter)\ ? ]] && chna="${chna/ / 0}"
        printf 'CHAPTER%03d=%s\n' "$chno" "$ts" >>  "$tmp/opusindex"
        printf 'CHAPTER%03dNAME=%s\n' "$chno" "$chna" >>  "$tmp/opusindex"
        rawindex+=( "$ts" )
        rawindex+=( "$chna" )
        createdindex+=( "$(printf 'CHAPTER%03dNAME=%s' "$chno" "$chna")" )
        createdindex+=( "$chno" )
        createdindex+=( "$(printf 'CHAPTER%03d=%s' "$chno" "$ts")" )
        createdindex+=( "$(printf 'CHAPTER%03dNAME=%s' "$chno" "$chna")" )
      else
        ts="00:00:00.000"
        chna="${chap_titles[$chno]}"
        [[ "$chna" = *@(Part|Chapter)\ ? ]] && chna="${chna/ / 0}"
        printf 'CHAPTER%03d=%s\n' "$chno" "$ts" >> "$tmp/opusindex"
        printf 'CHAPTER%03dNAME=%s\n' "$chno" "$chna" >>  "$tmp/opusindex"
        rawindex+=( "$ts" )
        rawindex+=( "$chna" )
        createdindex+=( "$chno" )
        createdindex+=( "$(printf 'CHAPTER%03d=%s' "$chno" "$ts")" )
        createdindex+=( "$(printf 'CHAPTER%03dNAME=%s' "$chno" "$chna")" )
      fi
    done

  mediainfo "$reintitle"
  printf '%s%sProposed index for %s:%s%s\n' "$red" "$bold" "$reintitle" "${tput0}" "$bold"
  printf '%s\t\t\t\t : %s\n' "${rawindex[@]}"
# printf '%s                             : %s\n' "${rawindex[@]}"
  sqlitepwd="${PWD//\'/\'\'}"
  itemid="$(sqlite3 "$abssqlite" "select id FROM libraryitems WHERE path=='$sqlitepwd';" ".exit")"
  printf '%s\n%sThis index was generated from existing %s;\n' "$tput0" "$relipsis" "$jsonfile"
  [[ "$itemid" ]] && printf '...look up new chapter information at\ngoogle-chrome %s/audiobook/%s/chapters\n\n\n' "$absserver" "$itemid"
  [[ ! "$itemid" ]] && printf '%s%s not found in absdatabase.sqlite!%s\n%sCheck path and metadata.json file\n\n\n' "$bold" "$PWD" "$tput0" "$red"

  if [[ "$rmmatch" = true ]]; then
    writeindex "$reintitle"
    [[ "$newchapters" = true ]] && curl -X POST "$absserver/api/items/$(itemid)/scan" -H "Authorization: Bearer $abstoken"
  elif confirm "${bold}${red}Apply index? ${tput0}"; then
    writeindex "$reintitle"
    [[ "$newchapters" = true ]] && curl -X POST "$absserver/api/items/$(itemid)/scan" -H "Authorization: Bearer $abstoken"
    rmmatch=true  #at this point, having said yes to apply index, yes the rest of the way.
  else
    mediainfo "$reintitle"
    printf '%s\t\t\t\t : %s\n' "${rawindex[@]}"
    if confirm "Would you like to start over so you can look up chapter information in audiobookshelf?"; then
      indexopus reindex
      exit
    else
      printf 'Not reindexing opus file with above index; exiting.'
      exit
    fi
  fi

  mediainfo *Audiobook.opus
  rm -rf "$tmp"

}
##reindex()####################################################################################

writeindex(){
  local output="$1" mp4tags mp4grep mp4opustags chaptag tags ck4tags args

  if [[ "$(opustags "$output")" = *CHAPTER* ]]
    then
      opustags -d "OverDrive MediaMarkers" -i "$output"
      printf '\n%s%s%s contains existing tags; removing...%s\n' "$relipsis" "$bold" "$title" "$tput0"
      tags=( $(opustags "$output") )
      tags=( $(printf -- '-d%s\n' "${tags[@]%=*}"|\grep CHAPTER|sort -u) )
      printf '\n%smediainfo of existing %s:%s\n' "$relipsis" "$output" "$tput0"
      mediainfo "$output"
      printf '\n%sremoving exiting CHAPTER tags with opustags...%s\n\n' "$relipsis" "$tput0"
      opustags "${tags[@]}" -i "$output"
      ck4tags=( "$(opustags "$output" | grep --color=always -i chapter)" ) &&
      printf 'Error!\nCHAPTER tags still present in opus file.\n%s' "${ck4tags[@]}" &&
      exit
  else
    printf '%smediainfo of existing %s:%s\n' "$relipsis" "$output" "$tput0"
    mediainfo "$output"
  fi

  while read -r chaptag
    do
      args+=(-a "$chaptag"\ )
    done < "$tmp/opusindex"

  opustags -i "$output" "${args[@]}"
  printf '%sChapter info added...\n%s' "$relipsis" "$tput0"
  printf '%sStripping MP4 tags%s\n%s' "$relipsis" "$relipsis" "$tput0"
  mp4tags=("major_brand" "minor_version" "compatible_brands" "encoded_by" "OverDrive MediaMarkers")
  mp4grep="$(IFS=\|; echo "${mp4tags[*]}")"
# mp4opustags="$(printf -- '-d %s ' "${mp4tags[@]}")"
  mp4opustags=( "$(printf -- '-d %s ' "${mp4tags[@]}")" )
  [[ $(opustags "$output" |grep -E "$mp4grep" ) ]] && opustags -i "$output" "${mp4opustags[@]}"
}
##--> writeindex() <--#################################################################################


##--> Main Code <--####################################################################################
##--> indexopus <--####################################################################################

echo
printline "${bold}  Welcome to ${white}indexopus  ${tput0}"
echo

# Parse command-line options
while [[ "$#" -gt 0 ]]; do
    if [[ "$1" = @(e|edit|--edit) ]]; then
        editscript;
    elif [[ "$1" = @(-y|--force) ]]; then
        rmmatch=true
    elif [[ "$1" = -f ]]; then
       fd="$2"; shift
    elif [[ "$1" = @(-d) ]]; then
        opuspartdur="$2"; shift
    elif [[ "$1" = @(-t|--title) ]]; then
        title="$2"; shift
    elif [[ "$1" = @(-s|--stamp) ]]; then
        stamp="$2"; shift
    elif [[ "$1" = @(-m|--tmp) ]]; then
        tmp="$2"; shift
    elif [[ "$1" = @(c|config|--config) ]]; then
        if [[ -n "$2" && -f "$2" && $(grep -q "absserver" "$2") ]]; then
            config="$2"
            shift
        else
#            if [[ -f "$confpath" && $(grep -q "absserver" "$confpath") ]]; then
#                config="$confpath"
#            fi
                echo "Default config file location: $confpath"
        fi
    elif [[ "$1" = @(-r|--reindex|reindex) ]]; then
        reindex=true
    elif [[ "$1" = @(-h|help|--help) ]]; then
        usage
    else
        echo "Unknown option: $1"
        exit 1
    fi
    shift
done

if [[ ! -d "$tmp" ]]; then
 mkdir "$tmp" || printf '%s%sFailed to create %s!\nexit 1\n%s' "$red" "$bold" "$tmp" "$tput0" #&& exit
fi

if [[ "$reindex" = true ]]   #if reindex is true, check for rmmatch and reindex.
 then
   reindex
   printf '%sPlease see %s/%s for indexed file.%s\n\n' "$red" "$PWD" "$reintitle" "$tput0"
   exit
fi


    opusarray=( *.opus )


# this checks for a metadata.json, ideally from audiobookshelf.  there could be other metadata.json files
# abs doesn't support json files with other names, nor is there anything in the json identifying it
# as an abs file.  It does check the .json for the chapter index, so there's at least that...
if [[ -f metadata.json ]] && [[ "$(jq -r '.chapters[0].title' metadata.json)" ]]
  then
    reindex=true
    [[ "$(jq -r '.chapters[0] | .title' metadata.json)".opus == "${opusarray[0]}" ]] ||
      [[ "$(jq -r '.chapters[0] | .title' metadata.json)" == "001" ]] &&
      reindex=false
    [[ "$reindex" = false ]] &&
      printf '%sA metadata.json file exists with duplicate chapter information; look up new chapter information at\ngoogle-chrome %s%s/chapters\n\n' "$red" "$absserver" "$(sqlite3 "$abssqlite" "select id FROM libraryitems WHERE path=='$PWD';" ".exit")" &&
      confirm "${bold}Would you like to try to reindex the file after importing chapter information?${tput0}" &&
      reindex=true
fi

if ! compgen -G @(*\ --\ Part\ ???\:\ *.opus|*\ --\ Part\ ??\:\ *.opus) &> /dev/null
 then
   if compgen -G @(*\ --\ Chapter\ ??*.opus|*\ --\ Disc\ ??.opus|*-Part??.opus) &> /dev/null
     then
       for renopus in *Chapter\ ??*.opus; do [[ -f "$renopus" ]] && mv "$renopus" "${renopus/ Chapter / Part }"; done
       for renopus in *Disc\ ??.opus; do [[ -f "$renopus" ]] && mv "$renopus" "${renopus/ Disc / Part }"; done
       for renopus in *-Part??.opus; do [[ -f "$renopus" ]] && mv "$renopus" "${renopus/-Part/ -- Part 00: Part }"; done
   fi

pause "$(printf '%s\n' "${opusarray[@]}")"

if [[ "${opusarray[@]}" =~ '^(.+ - \d{2}\.opus)$' ]]; then
 for renopus in *\ -\ {?..???}.opus; do
  mv "$renopus" "${renopus/ - / -- Part 00: Part }"
 done
fi

   renopus=( *\ --\ Part\ *.opus )

#  if [[ "${renopus[0]}" != @(*\ --\ Part\ ???\:\ *.opus|*\ --\ Part\ ??\:\ *.opus) ]]
   if ! compgen -G @(*\ --\ Part\ ???\:\ *.opus|*\ --\ Part\ ??\:\ *.opus) &> /dev/null
     then
       if [[ "${renopus[0]/ -- Part / -- Part 00: Part }" == *\ --\ Part\ ??\:\ *.opus ]]
         then
           for i in *opus
             do
               n="${i#* -- Part }"; n="${n%%.opus}"
               mv "$i" "${i/ -- Part / -- Part $n: Part }"
             done
         else
           printf 'This directory does not contain files in the format of %s<Title>%s -- Part ##:<Chapter Title>.opus\nPlease check the directory this script was launched from to make sure it contains the proper files.\n' "${ulon}" "${uloff}"
           exit
       fi
   fi
fi

d=0
t=0
gettitle "$title"

if [[ -f ./"$output" ]] && [[ "$rmmatch" != true ]]
 then
   printf 'This directory already contains %s\n' "$ioutput"
   if confirm "Overwrite the existing file? (y/n) "
    then
      printf '\n%sOverwriting %s -- Audiobook.opus...%s\n' "$relipsis" "$ititle" "${tput0}"
    else
      [[ -f metadata.json ]] &&
        confirm "$(printf '\nNot overwriting.\nA metadata.json file was found. Would you like to reindex the file?')" &&
        reindex=true && overwrite=false ||
        exit
   fi
fi


[[ "$opuspartdur" ]] && duration="$opuspartdur" ||
           duration=$(find . -type f \( -iname "$title -- Part ??:*.opus" -o -iname "$title -- Part ???:*.opus" \) -print0 |
           xargs -0 mplayer -vo dummy -ao dummy -identify 2>/dev/null |
           perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "%02d:%02d:%02d\n",$t/3600,$t/60%60,$t%60' |
           tail -n 1)

printf '\n%sGenerating the index for %s -- Audiobook.opus from...%s\n\n' "$relipsis" "$ititle" "$tput0"

createindex
printf '%s:~%s~%s\n\n' "${createdindex[@]}"|paste|column -t -s "~"
printf '\n%sConcatenating %s -- Part ??: *.opus...%s\n\n' "$relipsis" "$ititle" "$tput0"

#concatination step:
dirsize="$(du -csb *Part*opus|tail -n1)"
dirsize="${dirsize%%$'\t'*}" #remove everything after first tab stop
dirsize="$((dirsize/1000))" #convert bytes to KiB
printf '%sparts=  %sKiB time=%s%s\n' "$red" "$dirsize" "$duration" "$tput0"
[[ "$overwrite" != false ]] && ffmpeg -nostdin -hide_banner -v error -stats -f concat -safe 0 -thread_queue_size 1024 -i "$tmp/opusfiles" -n -acodec copy "/tmp/$output"
[[ "$overwrite" != false ]] && [[ "$?" != 0 ]] && echo && echo "ffmpeg failed to concatinate; exit 1" && echo && exit 1

printf '\n\n%sIncorporating index into%s %s -- Audiobook.opus%s\n\n%s' "$relipsis" "$white" "$ititle" "$relipsis" "$tput0"

mv "/tmp/$output" "$output"

writeindex "$output"

if [[ -f "$output" ]] && eval command -v mediainfo &> /dev/null; then
  printf '%sChecking output from mediainfo...\n\n%s' "$relipsis" "$tput0"
  mediainfo "$output"
  outdur="$(mediainfo -f "$output"|grep Duration|head -n1)"
  outdur="${outdur#*: }"
  outdur="$(echo "$outdur" | perl -nle '/([0-9\.]+)/ && ($t += $1) && printf "%02d:%02d:%02d\n", $t/3600000, ($t/60000)%60, ($t/1000)%60')"

  data=( "${bold}Duration(s):${tput0}"
         "${red}${bold} $duration ${tput0}${ititle} -- Part .*opus $tput0"
         "${red}${bold} $outdur ${tput0}${ititle} -- Audiobook.opus $tput0")

  # Print the aligned data using column, right justifying durations
  printf '%s\n' "${data[@]}" #| column -s "~" -t -R 2
  echo "$tput0 $white"
elif [[ -f "$output" ]] && eval command -v ffprobe &> /dev/null; then
  printf 'Checking the output from ffprobe...\n\n'
  ffprobe "$output"
  printf 'Original duration... %s' "$duration"
else
  echo "Indexed opus file not found! Exit 1"
  rmyn "remove $tmp? " "leaving files" rm -r "$tmp"
# (( $rmynres == 1 )) && >&2 echo "$tmp"
  printline "${bold}  Exiting (1) ${white}indexopus  ${tput0}"
  exit 1
fi

if [[ "$rmmatch" && "$duration" = "$outdur" ]]; then
  printf '%sDurations of part and indexed opus files match, automatically deleting temporary files!\n\nPlease see %s%s%s/%s%s\n\n%sDone.\n\n%s' "$relipsis" "$white" "$bold" "$PWD" "$ioutput" "$tput0" "$relipsis" "$tput0"
  rm -r "$title"\ --\ Part\ *.opus "$tmp"/opus@(files|index)
  printline "${bold}  Exiting (0) ${white}indexopus  ${tput0}"
  exit 0
fi

[[ "$reindex" = true ]] && confirm "$(printf '%sA metadata.json file was found!\n%sReindex the file with audiobookshelf chapter info?%s' "${red}" "${bold}" "${tput0}")" && indexopus reindex

#this isnt working right tonight and it is late.
[[ "$reindex" != true ]] && rmyn "${bold}${red}Remove $title -- Part *.opus & temp files? (y/n) ${tput0}" "$bold Leaving temporary files $tput0" rm -r "$title"\ --\ Part\ *.opus "$tmp"/opus@(files|index) && iorm=true ||
 rm -r "$title"\ --\ Part\ *.opus "$tmp"/opus@(files|index)

printf '\n\n%sDone.\n\nPlease see %s%s%s/%s\n\n' "$relipsis" "$white" "$bold" "$PWD" "$ioutput"

#exec 5<> "$tmp/5"

(( $rmynres == 1 )) 2>/dev/null && echo "$tmp remains"

#clean up /tmp/indexopus-* files older than a day:
find /tmp -iname "indexopus-1*" -mtime -1 -exec rm -rf {} 2>/dev/null \;

printf '%s' "$tput0"

printline "${bold}  Exiting (0) ${white}indexopus  ${tput0}"
echo

[[ "$iorm" = true ]] && exit 2 || exit 0 # this exit 2 has to be here so that it is passed back to m4b2opus

exit 1 #how did it get here?!?




to get chapters for a new abs book, it looks like the following api calls:
curl -X POST "$absserver/api/items/$(itemid)/scan"   -H "Authorization: Bearer $abstoken"
curl "$absserver/api/search/chapters?asin=$(jq -r '.asin' metadata.json)"   -H "Authorization: Bearer $abstoken" >chapters.json
curl -X POST "$absserver/api/items/$(itemid)/match"   -H "Authorization: Bearer $abstoken"   -H "Content-Type: application/json"   -d '{"provider": "audible", "overrideDefaults": "true"}'

