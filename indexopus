#!/bin/bash
# depends: opustags, ffmpeg/ffprobe
# optional: mediainfo
# files must be in the format of Title -- Part ##: Chapter Title.opus and present ONLY works for .opus; there are other tools for e.g., m4b: use them.
# presumably, this script could easily be changed out for another codec, however opustags would need to change to something else that can write metadata, e.g, ffmpeg which should be able to do any format.
# that said, the author feels that this satisfices for the purposes at hand and if/when the codec changes, that bridge will be burnt when it is arrived upon.
# Would like to make it so that the files do not need a chapter name and are iterated with 000, 001, 002, .... for Chapter Title
# ffmpeg could presumably take over for opustags to eliminate that dependency and then all that would be required is ffmpeg
# Also, given that tagging is being done, it might be useful to tag at least the tracknumber and the track title in this script rather than doing it after.
#
# Promlem with colons in the part description:
# That could still indicate a problem if the code is later attempting to do shell arithmetic on the value, in which case you got lucky by having printf throw an error. You could fix that by adding a test and failing early, because printf won't cause the script to exit.
# https://mywiki.wooledge.org/BashFAQ/054 -- How can I tell whether a variable contains a valid number?


shopt -s extglob
scriptname=$(realpath "$0")
ulon="$(tput smul)"  #underline on
uloff="$(tput rmul)" #underline off
red="$(tput setaf 9)" #red fg
white="$(tput setaf 15)" #white fg
tput0="$(tput sgr0)" #reset tput changes
bold="$(tput bold)" #bold on

editscript(){
  local script path; script="${scriptname##*/}"; path="${scriptname%/*}"; swp="$path/.$script.swp"
     if [[ ! -e "$swp" ]]; then printf "\n\n%s\n\n" "$swp"; (/usr/bin/nano "$scriptname"); exit
     else printf "\n%s is already being edited.\n%s exists; try fg or look in another window.\n" "$scriptname" "$swp"; exit;
  fi; }

pause(){ read -p "$*" ; }

confirm(){
 local ans IFS=
 while
  printf '%s' "$1"
  read -rp " " -n1 ans
   do
     printf '\n'
     case "$ans" in [Yy]) return 0;; [Nn]) return 1;;
     esac
   done
}

#unused
tagtt(){
for i in *\ --\ Part\ ??\:\ *opus
 do
   title="${i%.opus}"
   title="${title#* -- }"
   tracknumber="${i%:*}"
   tracknumber="${tracknumber#*Part }"
   opustags -i "$i" -s title="$title" -s tracknumber="$tracknumber"
done
}


rmyn(){
  while true
  read -rp "$1" rmyn
   do
     case "$rmyn" in
       [yY] ) "${@:3}"; break;;
       [nN] ) printf '\n%s\n' "$2"; break;;
          * ) printf "Invalid response...\n";;
     esac
   done
}

yn(){
  while true
  read -p "$1" yn
   do
     case "$yn" in
       [yY] ) "$2"; break;;
       [nN] ) "$3"; break;;
          * ) printf "Invalid response...\n";;
     esac
   done
}


is_even() {
    if [ $(( $1 % 2 )) -eq 0 ]; then return 0
    else return 1; fi
}


gettitle(){
titles=(*Part\ 0?*.opus)
ext="${titles[0]##*.}"
[[ ! -n "$title" ]] && title="${titles[0]% -- Part*}"
ititle="${ulon}$title${uloff}"
output="$title -- Audiobook.opus"
ioutput="$ititle -- Audiobook.opus"
}

createindex(){
declare -A associndex
chno=0
for i in "$title -- Part "*.opus
 do
#   chno="${i#*Part }"; chno="${chno%%:*}"; chno="${chno#00}"; chno="${chno#0}"
   chna="${i#* -- Part }"; chna="${chna%.opus}"; chna="${chna#*: }"

   if [[ "$t" != 0 ]]
    then
      ts=$(echo "$t" | perl -nle '/([0-9\.]+)/ && ($t +=$1) && printf "%02d:%02d:%06.03f\n", $t/3600, $t/60%60, $t%60 + $t-int($t)' | tail -n 1)
      printf 'CHAPTER%03d=%s\n' "$chno" "$ts" >>  ./tmp/opusindex
      printf 'CHAPTER%03dNAME=%s\n' "$chno" "$chna" >>  ./tmp/opusindex
      createdindex+=( "$i" )
      createdindex+=( "$(printf 'CHAPTER%03d=%s' "$chno" "$ts")" )
      createdindex+=( "$(printf 'CHAPTER%03dNAME=%s' "$chno" "$chna")" )

    else
      ts="00:00:00.000"
      printf 'CHAPTER%03d=%s\n' "$chno" "$ts" >> ./tmp/opusindex
      printf 'CHAPTER%03dNAME=%s\n' "$chno" "$chna" >>  ./tmp/opusindex
      createdindex+=( "$i" )
      createdindex+=( "$(printf 'CHAPTER%03d=%s' "$chno" "$ts")" )
      createdindex+=( "$(printf 'CHAPTER%03dNAME=%s' "$chno" "$chna")" )
   fi
      d=$(ffprobe -v error -show_entries format=duration -of default=nk=1:nw=1 "$i")
#      d=$(mplayer -vo dummy -ao dummy -identify "$i" 2>/dev/null | perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "$t"' | tail -n 1)
      t=$(echo "$d + $t" | bc)
      ((chno++))
done

#printf 'Word -> %s\n' "${createdindex[@]}" #|column --table -s '~' -o ' | '
#column ./tmp/opusindex IFS="$'\n'" -o " | " -t

}



#### ---- Main Code ---- ####

[[ "$1" = @(edit|e|nano) ]] && editscript

[[ "$1" = "-y" ]] && shift && rmmatch=true

if ! compgen -G @(*\ --\ Part\ ???\:\ *.opus|*\ --\ Part\ ??\:\ *.opus) > /dev/null
 then
   if compgen -G @(*\ --\ Chapter\ ??*.opus|*\ --\ Disc\ ??.opus) > /dev/null
     then
       for renopus in *Chapter\ ??*.opus; do [[ -f "$renopus" ]] && mv "$renopus" "${renopus/ Chapter / Part }"; done
       for renopus in *Disc\ ??.opus; do [[ -f "$renopus" ]] && mv "$renopus" "${renopus/ Disc / Part }"; done
   fi


   renopus=(*Part\ 01*.opus)
   if [[ "${renopus[0]/ -- Part / -- Part 00: Part }" == *\ --\ Part\ ??\:\ *.opus ]]
     then
       for i in *opus
         do
           n="${i#* -- Part }"; n="${n%%.opus}"
           mv "$i" "${i/ -- Part / -- Part $n: Part }"
         done
   else
     printf 'This directory does not contain files in the format of %s<Title>%s -- Part ##:<Chapter Title>.opus\nPlease check the directory this script was launched from to make sure it contains the proper files.\n' "${ulon}" "${uloff}"
     exit
   fi
fi

#ffprobe -sexagesimal -> "00:00:00.00"
d=0
t=0

if [[ -d ./tmp ]]
 then
   rm -r ./tmp && mkdir ./tmp
 else
   mkdir ./tmp
fi


[[ -n "$1" ]] && title="$1"

gettitle "$title"

echo "$title"

if [[ -f ./"$output" ]] && [[ "$rmmatch" != true ]]
 then
   printf 'This directory already contains %s\n' "$ioutput"
   if confirm "Overwrite the existing file? (y/n)"
    then
      printf '\n...Overwriting %s -- Audiobook.opus...\n' "$ititle"
      elipsis="..."
    else
      exit
   fi
fi

[[ "$2" ]] && duration="$2" ||
           duration=$(find . -type f \( -iname "$title -- Part ??:*.opus" -o -iname "$title -- Part ???:*.opus" \) -print0 |
           xargs -0 mplayer -vo dummy -ao dummy -identify 2>/dev/null |
           perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "%02d:%02d:%02d\n",$t/3600,$t/60%60,$t%60' |
           tail -n 1)

printf '\n%sGenerating the index for %s -- Audiobook.opus from...\n\n' "$elipsis" "$ititle"

createindex

printf '%s:~%s~%s\n\n' "${createdindex[@]}"|paste|column -t -s "~"
printf '\n...Concatenating %s -- Part ??: *.opus...\n\n' "$ititle"

for f in @("$title -- Part "??\:\ *.opus|"$title -- Part "???\:\ *.opus)
 do
   if [[ "$PWD/$f" == *\'* ]]
    then
       ff="$f"; dir="$PWD"
       [[ "$f" == *\'* ]] && ff="${f//\'/\'\\\'\'}" || ff="$f"  #ffmpeg will not take filenames with ' in them, they must be quoted:
       [[ "$PWD" = *\'* ]] && dir="${PWD//\'/\'\\\'\'}"
       echo "file '$dir/$ff'" >> ./tmp/opusfiles
    else
      echo "file '$PWD/$f'" >> ./tmp/opusfiles
    fi
done

ffmpeg -nostdin -hide_banner -stats -f concat -safe 0 -thread_queue_size 1024 -i "./tmp/opusfiles" -n -acodec copy "./tmp/$output"
[[ "$?" != 0 ]] && echo && echo "ffmpeg failed to concatinate; exit 1" && echo && exit 1

printf '\n\n...Incorporating index into %s -- Audiobook.opus...\n\n' "$ititle"

mv "./tmp/$output" "$output"

while read -r chaptag
 do
   args+=(-a "$chaptag")
 done < "./tmp/opusindex"

opustags -i "$output" "${args[@]}"

printf '...Chapter info added...\n\n'

if [[ -f "$output" ]] && eval command -v mediainfo &> /dev/null
 then
   printf '...Checking output from mediainfo...\n\n'

   outdur="$(mediainfo -f "$output"|grep Duration|head -n1)"
   outdur="${outdur#*: }"
   outdur="$(echo "$outdur" | perl -nle '/([0-9\.]+)/ && ($t += $1) && printf "%02d:%02d:%02d\n", $t/3600000, ($t/60000)%60, ($t/1000)%60')"

   data=("The duration of the $ititle -- Part *opus is ~$bold$red$duration$tput0"
         "The duration of the $ititle -- Audiobook.opus is ~$bold$red$outdur$tput0")

   # Print the aligned data using column, right justifying durations
   printf '%s\n' "${data[@]}" | column -s "~" -t -R 2

   elif [[ -f "$output" ]] && eval command -v ffprobe &> /dev/null
     then
       printf 'Checking the output from ffprobe...\n\n'
       ffprobe "$output"
      printf 'Original duration... %s' "$duration"
   else
     echo "Indexed opus file not found! Exit 1"
     exit 1
fi

[[ "$rmmatch" ]] &&
   [[ "$duration" = "$outdur" ]] &&
   rm -r "$title"\ --\ Part\ ??:*.opus ./tmp &&
   printf 'Durations of part and indexed opus files match, deleting temporary files.\n\n...Done.\n\nPlease see %s/%s\n\n' "$PWD" "$ioutput" &&
   exit

rmyn "Remove temporary files? (y/n) " "$bold Leaving temporary files $tput0" rm -r "$title"\ --\ Part\ ??:*.opus ./tmp

printf '\n\n...Done.\n\nPlease see %s/%s\n\n' "$PWD" "$ioutput"

exit



