#!/bin/bash
#depends opustags, ffmpeg, indexopus, opus.book.4, mplayer, mediaduration
#need to address existing m4a files in the convert directory prior to the m4b to m4a split.

#trap pause DEBUG
shopt -s nullglob

scriptname=$(realpath "$0")
ulon=$(tput smul)  #underline on
uloff=$(tput rmul) #underline off
bold="$(tput bold)"  #bold on
tput0="$(tput sgr0)" #clear tput
red="$(tput setaf 9)" #red fg
white="$(tput setaf 15)" #white fg
relipsis="$red..."
stamp="$(date +%s)"

##definitions#################################################################################

pause(){ read -p "$*" ; }
##--> pause() <--#############################################################################


fnrmr(){
  fn_rmfile(){
    printf "%s\n%s is a file:\n" "$bold" "$1"
    ls -ltr "$1"
    printf '\nrmr: remove this file? (y/n) %s' "$tput0"
    old_stty_cfg=$(stty -g)
# https://stackoverflow.com/questions/226703/how-do-i-prompt-for-yes-no-cancel-input-in-a-linux-shell-script
    stty raw -echo
    answer=$(head -c 1)
    stty "$old_stty_cfg"
# Careful playing with stty

    if [ "$answer" != "${answer#[Yy]}" ]
      then
      rm "$1"
      printf "\n\n"
      if [ ! -e "$1" ]
        then
        printf "\nDone! File \"%s\" removed.\n\n" "$1"
      else
        printf "\n\n%s%s not removed, check permissions:\n\n" "$bold" "$1"; ls -ltr "$1"
      fi
    else
      printf '\n\n%sFiles remain:\n%s \n%s\n' "$red" "$(ls -ltr "$1")" "$tput0"
    fi

#	There isn't really anything wrong with this code, but the above method removes the CR
#	There're other ways to do this https://stackoverflow.com/questions/226703/how-do-i-prompt-for-yes-no-cancel-input-in-a-linux-shell-script

   }
  ##--> fn_rmfile() <--###############################################################################


for path in "$@"
  do
    if [[ -d "$path" ]]; then
	printf '%s\n' "$bold"
	if rmdir "$path" 2>/dev/null; then
	   printf 'Removing %s... \n\n$ ls %s/ \n\n' "$path" "$path"
	else
	   printf '\n%s' "$tput0"
	   find "$path"
 	   printf '%s' "$bold"
	   rm -rI "$path"
	   printf '%s' "$tput0"
	fi

	if [ ! -e "$path" ]; then
      	   printf '\nDone!\n'
      	else
      	   printf '\n\n%sRemoval Failed!%s\n\n%s is still present check ownership and permissions:\n' "$bold" "$tput0" "$path"
      	   ls -lad --color=always "$path"
	fi
  elif [[ -f "$path" ]]; then
    fn_rmfile "$path"

  else
    printf '\n\n No such directory or file found!\n\n'

  fi

done
}
##--> fnrmr() <--###################################################################################

editscript(){
  local script path; script="${scriptname##*/}"; path="${scriptname%/*}"; swp="$path/.$script.swp"
     if [[ ! -e "$swp" ]]; then printf "\n\n%s\n\n" "$swp"; (/usr/bin/nano "$scriptname"); exit
     else printf "\n%s is already being edited.\n%s exists; try fg or look in another window.\n" "$scriptname" "$swp"; exit;
  fi; }
##--> editscript() <--##############################################################################

filecheck(){
   clifilename="$1"
   [[ -d "$clifilename" ]] && isdir=true && clidir="$cilfilename" && cd "$clidir"
   [[ -f "$clifilename" ]] && isfile=true && clidir="${clifilename%/*}" && cd "$clidir"

  if [[ ! -z "$1" ]] && [[ "$1" != *\ --\ Audiobook.m4b ]]
    then
      printf 'The file specified: %s\nis not in the correct format of\n* -- Audiobook.m4b, checking directory for an m4b file...' "$1"
  elif [[ "$1" == *\ --\ Audiobook.m4b ]] && [[ -f "$1" ]]  #suggested this is poor design to ignore the input if it is not in the correct format.
    then
      m4bin="$1"
  else
      files=(*m4b)
      if [[ -f "$files" ]] && [[ "${#files[@]}" == 1 ]]
       then
         if [[ "$files" == *\ --\ Audiobook.m4b ]]
          then
            m4bin="$files"
         elif [[ "$files" == *m4b ]]
          then
            m4bin="${files/.m4b/ -- Audiobook.m4b}"
            mv "$files" "$m4bin"
         fi
      else
        echo "No single & appropriate input file found or specified, please check and retry..."
        ls
        exit 1
      fi
  fi; }
##--> filecheck() <--#################################################################################

calculatetime(){
duration=$(find -type f -name "$1" -print0 |
xargs -0 mplayer -vo dummy -ao dummy -identify 2>/dev/null |
perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "%02d:%02d:%02d\n",$t/3600,$t/60%60,$t%60' |
tail -n 1)
 hours=$(find -type f -name "$1" -print0 | xargs -0 mplayer -vo dummy -ao dummy -identify 2>/dev/null | perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "%02d\n",$t/3600' | tail -n 1)
 minutes=$(find -type f -name "$1" -print0 | xargs -0 mplayer -vo dummy -ao dummy -identify 2>/dev/null | perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "%02d\n",$t/60%60' | tail -n 1)
 seconds=$(find -type f -name "*$1" -print0 | xargs -0 mplayer -vo dummy -ao dummy -identify 2>/dev/null | perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "%02d\n",$t%60' | tail -n 1)

 [[ "$hours" =~ "0*(.*)" ]] && hours=${BASH_REMATCH[1]}
 [[ "$minutes" =~ "0*(.*)" ]] && minutes=${BASH_REMATCH[1]}
 [[ "$seconds" =~ "0*(.*)" ]] && seconds=${BASH_REMATCH[1]}

 printf "Duration %s\n" "$duration"

 hours="${hours#0}"
 hourmin=$(( hours*60 ))
 ##echo "hourmin $hourmin"
 minutes="${minutes#0}"
 secmin=$((hourmin+minutes))
 secmin=$((secmin*60))
 seconds="${seconds#0}"
 ##echo "secmin  $secmin"
 ##echo "seconds $seconds"
 totalsec=$(( "$seconds" + "$secmin" ))
 ##echo "totalsec $totalsec"
 divsec=$(python3 -c "print($totalsec/4)")
 ##echo "divsec $divsec"
}
##--> calculatetime{} <--#############################################################################

m4bsplit(){
# Original code from: http://crunchbang.org/forums/viewtopic.php?id=38748#p414992
# m4bronto

#     Chapter #0:0: start 0.000000, end 1290.013333
#       first   _     _     start    _     end
local bpath outputdur START first start end partnum n
outputdir="$2"
START=1
bpath="$(basename "$PWD")"

while [ "$#" -gt 0 ]; do

ffmpeg -i "$1" 2> ".tmp$stamp"

n="$START"

while read -r first _ _ start _ end
 do
  if [[ "$first" = Chapter ]]
   then
      read  # discard line with Metadata:
      read _ _ chapter
      [[ "$chapter" = Chapter\ ?\:\ * ]] && chapter="${chapter/Chapter /Chapter 0}"
      [[ "$n" -lt 10 ]] && partnum="0$n" || partnum="$n"
      printf '%sCreating %s -- Part %s: %s.m4a%s\n' "$relipsis" "$title" "$partnum" "$chapter" "$tput0"
      readarray -t ffoutput < <(ffmpeg -n -nostdin -hide_banner -stats -v error -vsync 2 -ss "${start%?}" -to "$end" -i "$1" -vn -codec copy "$outputdir/$title -- Part $partnum: $chapter.m4a" 2>&1)
      ((n++))
  fi
done <".tmp$stamp"

rm ".tmp$stamp"

shift
done
}
##--> m4bsplit() <--##################################################################################

checkdur(){
  local m4a m4b opus
  m4a=(*m4a)
  m4b=(*m4b)
  opus=(*opus)

if [[ "$1" ]]
  then
      find -type f -iname "*.$1" -print0 | xargs -0 mplayer -vo dummy -ao dummy -identify 2>/dev/null | perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "%02d:%02d:%02d\n",$t/3600,$t/60%60,$t%60' | tail -n 1
  else
    printf '\n%sDuration(s):%s\n' "$bold" "$tput0"
    [[ "${#m4a[@]}" -gt 0 ]] &&
      printf '%s %s%s%s %s%s\n' "$bold" "$red" "$(    find -type f -iname "*.m4a" -print0 | xargs -0 mplayer -vo dummy -ao dummy -identify 2>/dev/null | perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "%02d:%02d:%02d\n",$t/3600,$t/60%60,$t%60' | tail -n 1)" "$white"  "${m4a[@]}" "$tput0"
    [[ "${#m4b[@]}" -gt 0 ]] &&
      printf '%s %s%s%s %s%s\n' "$bold" "$red" "$(    find -type f -iname "*.m4b" -print0 | xargs -0 mplayer -vo dummy -ao dummy -identify 2>/dev/null | perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "%02d:%02d:%02d\n",$t/3600,$t/60%60,$t%60' | tail -n 1)" "$white" "${m4b[@]}" "$tput0"
    [[ "${#opus[@]}" -gt 0 ]] &&
      printf '%s %s%s%s %s%s\n' "$bold" "$red" "$(    find -type f -iname "*.opus" -print0 | xargs -0 mplayer -vo dummy -ao dummy -identify 2>/dev/null | perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "%02d:%02d:%02d\n",$t/3600,$t/60%60,$t%60' | tail -n 1)" "$white" "${opus[@]}" "$tput0"
 fi
}
##--> checkdur() <--##################################################################################

rmyn(){
  while true
  read -rp "$1" rmyn
   do
     case "$rmyn" in
       [yY] ) "${@:3}"; break;;
       [nN] ) printf '%s\n' "$2"; break;;
          * ) printf "Invalid response...\n";;
     esac
   done
}
##--> rmyn() <--######################################################################################


##--> Main Code <--################################################################################
##--> m4b2opus <--####################################################################################

[[ "$1" == @(edit|e|nano) ]] && editscript

[[ "$1" == "-y" ]] && shift && rmmatch=true

#[[ "$1" ]] && clifile "$1"

filecheck "$1" && [[ ! "$?" == 0 ]] && exit

allm4s=(*m4?)

printf '\n%s/*m4?: \n' "$PWD"
printf ' %s%s%s\n' "$red" "${allm4s[@]}" "$white"

[[ "$stats" = true ]] && mediainfo "$m4bin"

m4bindur="$(checkdur m4b)"

printf '\n%sStarting .m4b file:%s' "$bold" "$tput0"
printf ' %s%s%s%s\n' "$bold" "$red" "$m4bin" "$tput0"
printf '%sStarting duration :%s' "$bold" "$tput0"
printf ' %s%s%s\n' "$red" "$bold" "$m4bindur" "$tput0"

title="${m4bin% -- *}"
swd="$PWD"
convertdir="$CACHE/m4b2opus-$title"

[[ "$convertdir" == *\'* ]] && convertdir="${convertdir//\'}"  #check $convertdir for \'s and remove them

[[ ! -d "$convertdir" ]] && mkdir "$convertdir"

if [[ ! "$(mediainfo "$m4bin"|grep Menu)" =~ ^Menu ]]
  then
    qtcnt=1
    calculatetime "$m4bin"
    while [[ "$qtcnt" -lt 5 ]]
      do
       printf '%s: ' "$qtcnt"
       ffmpeg -n -nostdin -hide_banner -stats -v error -ss $(python -c "print(($qtcnt-1)*$divsec)") -to $(python -c "print($qtcnt*$divsec)") -i "$m4bin" -vn -acodec copy "$convertdir/${m4bin%% -- *} -- Part 0$qtcnt.m4a"
       ((qtcnt++))
     done
    cd "$convertdir"
    for i in First Second Third Fourth
      do
        ((n++))
        for f in *\ --\ Part\ 0"$n".*
          do
           mv "$f" "${f/./: $i Quarter.}"
          done
       done
  else
    m4bsplit "$m4bin" "$convertdir"
    cd "$convertdir"
    regexexp='.*\ --\ Part\ [[:digit:]]{2}:\ Chapter\ [[:digit:]][\ |\.]'
    for m4afile in *m4a
      do
        [[ "$m4afile" =~ .*\ --\ Part\ [[:digit:]]{2}:\ Chapter\ [[:digit:]][\.\ ] ]] &&
           mv "$m4afile" "${m4afile/Chapter /Chapter 0}"
      done
fi

cd "$convertdir"

#probably remove the following 3 lines as the output is redundant.
#printf '\n'
#ls "$convertdir"
#printf '\n'

echo
[[ "$rmmatch" != true ]] && pause "${bold}${red}Control-Z to suspend to change to $convertdir and adjust chapter names?${tput0} "

printf '\n'
printf '%s\n----------  Calling external dependency: %sopus.book.4%s  ----------\n' "$bold" "$red" "$tput0"
opus.book.4  #this is a dependency; needs to be made a function?
if (( "$?" > 1 ))
  then
    echo "opus.book.4 failed; exit 1"
#    exit 1
fi
printf '\n'
printf '%s\n----------  Leaving external dependency: %sopus.book.4%s  ----------\n' "$bold" "$red" "$tput0"
#opus.book.4##################################################################################

clear -x

[[ ! -d "$convertdir/m4a" ]] && mkdir "$convertdir/m4a"
mv *.m4a ./m4a
opuspartdur="$(checkdur opus)"
m4bindur="${m4bindur#*: }"

printf '\n%sDuration of the original m4b file: %s%s%s\n' "$bold" "$red" "$m4bindur" "$tput0"
printf '%sDuration of the .opus part files: %s%s%s\n' "$bold" "$red" "$opuspartdur" "$tput0"

printf '\n\n%s----------  Calling external dependency: %sindexopus%s  ----------\n' "$bold" "$red" "$tput0"
printf '%s' "$white"  #does this help with the prompt disappearing after return from indexopus?
echo                  # We'll see?

if [[ "$rmmatch" = true ]]
  then
    indexopus -y "$title" 	# "$opuspartdur" is there realistically a way to pass the opus part durations?
  else
    indexopus "$title" 		# this is a dependency, don't make a funciton.
fi
   ec4io="$?" 				# error code 4 indexopus
   [[ "$ec4io" = 2 ]] && iorm=true
   [[ "$ec4io" = 1 ]] && printf 'indexopus exited for some unknown reason with exit 1. investigate.\nexit 1' && exit 1

printf '\n\n%s----------  Leaving external dependency: %sindexopus%s  ----------\n' "$bold" "$red" "$tput0"
##indexopus##################################################################################

titleopus="$title -- Audiobook.opus"
[[ ! -f "$titleopus" ]] && printf '%s%sWhere the fuck is %s?! Exiting (1)\n%s' "$bold" "$red" "$titleopus" "$tput0"
mv "$titleopus" "$swd"
cd "$swd"

if [[ "$rmmatch" = true ]] && [[ "$(checkdur m4b)" = "$(checkdur opus)" ]]
  then
    rm -r *m4b "$convertdir"
    printf '\n\n...Done.\n\nPlease see %s/%s\n\n' "$PWD" "$ioutput"
elif [[ "$rmmatch" = true ]] && [[ "$(checkdur m4b)" != "$(checkdur opus)" ]]
  then
    printf '%s%sThe m4b and opus audiobook durations do not match!\n' "$bold" "$red"
    printf '%s%sm4b2opus will not automatically delete starting and temporary files!\n' "$white" "$tput0"
    ls "$tmp" "$convertdir/m4a" 2>/dev/null
    checkdur
    printf '\n\n'
# the 2>/dev/null does not work for rmyn -- rewrite!!
    rmyn "Remove the conversion ./m4a directory? " "...Leaving ./m4a" rm -r "$convertdir"/m4a #2>/dev/null
    [[ ! "$iorm" ]] && rmyn "Remove $ititle -- Part *.opus files? " "...Leaving $ititle -- Part *.opus files..." rm "$convertdir/$title"\ --\ Part\ ??:*.opus
    fnrmr *m4b "$convertdir" .tmp* #rmr is a dependency
    printf '\n\n...Done.\n\nPlease see %s/%s\n\n' "$PWD" "$ioutput"
else
    ls "$tmp" "$convertdir/m4a" 2>/dev/null
    checkdur
    printf '\n\n'
# the 2>/dev/null does not work for rmyn -- rewrite!!
    rmyn "Remove the conversion ./m4a directory? " "...Leaving ./m4a" rm -r "$convertdir/m4a" #2>/dev/null
    [[ ! "$iorm" ]] && rmyn "Remove $ititle -- Part *.opus files? " "...Leaving $ititle -- Part *.opus files..." rm "$convertdir/$title"\ --\ Part\ ??:*.opus
    fnrmr *m4b "$convertdir" .tmp*
    printf '\n\n...Done.\n\nPlease see %s/%s\n\n' "$PWD" "$ioutput"
fi





