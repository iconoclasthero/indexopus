#!/bin/bash
#depends opustags, ffmpeg, indexopus, opus.book.4, mplayer, rmr, mediaduration(?)

#trap pause DEBUG
shopt -s nullglob

scriptname=$(realpath "$0")
ulon=$(tput smul)  #underline on
uloff=$(tput rmul) #underline off
bold="$(tput bold)"  #bold on
tput0="$(tput sgr0)" #clear tput
red="$(tput setaf 9)" #red fg
white="$(tput setaf 15)" #white fg
##definitions#################################################################################

pause(){ read -p "$*" ; }
##pause()#####################################################################################

editscript(){
  local script path; script="${scriptname##*/}"; path="${scriptname%/*}"; swp="$path/.$script.swp"
     if [[ ! -e "$swp" ]]; then printf "\n\n%s\n\n" "$swp"; (/usr/bin/nano "$scriptname"); exit
     else printf "\n%s is already being edited.\n%s exists; try fg or look in another window.\n" "$scriptname" "$swp"; exit;
  fi; }
##editscript()################################################################################

filecheck() {
  if [[ ! -z "$1" ]] && [[ "$1" != *\ --\ Audiobook.m4b ]]
    then
      printf 'The file specified: %s\nis not in the correct format of\n* -- Audiobook.m4b, checking directory for an m4b file...' "$1"
  elif [[ "$1" == *\ --\ Audiobook.m4b ]] && [[ -f "$1" ]]  #suggested this is poor design to ignore the input if it is not in the correct format.
    then
      m4bin="$1"
  else
      files=(*m4b)
      if [[ -f "$files" ]] && [[ "${#files[@]}" == 1 ]]
       then
         if [[ "$files" == *\ --\ Audiobook.m4b ]]
          then
            m4bin="$files"
         elif [[ "$files" == *m4b ]]
          then
            m4bin="${files/.m4b/ -- Audiobook.m4b}"
            mv "$files" "$m4bin"
         fi
      else
        echo "No single & appropriate input file found or specified, please check and retry..."
        ls
        exit 1
      fi
  fi; }
##filecheck()#################################################################################

calculatetime(){
 duration=$(find -type f -name "$1" -print0 | xargs -0 mplayer -vo dummy -ao dummy -identify 2>/dev/null | perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "%02d:%02d:%02d\n",$t/3600,$t/60%60,$t%60' | tail -n 1)
 hours=$(find -type f -name "$1" -print0 | xargs -0 mplayer -vo dummy -ao dummy -identify 2>/dev/null | perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "%02d\n",$t/3600' | tail -n 1)
 minutes=$(find -type f -name "$1" -print0 | xargs -0 mplayer -vo dummy -ao dummy -identify 2>/dev/null | perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "%02d\n",$t/60%60' | tail -n 1)
 seconds=$(find -type f -name "*$1" -print0 | xargs -0 mplayer -vo dummy -ao dummy -identify 2>/dev/null | perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "%02d\n",$t%60' | tail -n 1)

 [[ "$hours" =~ "0*(.*)" ]] && hours=${BASH_REMATCH[1]}
 [[ "$minutes" =~ "0*(.*)" ]] && minutes=${BASH_REMATCH[1]}
 [[ "$seconds" =~ "0*(.*)" ]] && seconds=${BASH_REMATCH[1]}

 printf "Duration %s\n" "$duration"

 hours="${hours#0}"
 hourmin=$(( hours*60 ))
 ##echo "hourmin $hourmin"
 minutes="${minutes#0}"
 secmin=$((hourmin+minutes))
 secmin=$((secmin*60))
 seconds="${seconds#0}"
 ##echo "secmin  $secmin"
 ##echo "seconds $seconds"
 totalsec=$(( "$seconds" + "$secmin" ))
 ##echo "totalsec $totalsec"
 divsec=$(python3 -c "print($totalsec/4)")
 ##echo "divsec $divsec"
}  
##calculatetime{}#############################################################################

m4bsplit(){
# Original code from: http://crunchbang.org/forums/viewtopic.php?id=38748#p414992
# m4bronto

#     Chapter #0:0: start 0.000000, end 1290.013333
#       first   _     _     start    _     end
local stamp bpath outputdur START first start end partnum n
outputdir="$2"
START=1
bpath="$(basename "$PWD")"
stamp="$(date +%s)"

while [ "$#" -gt 0 ]; do

ffmpeg -i "$1" 2> ".tmp$stamp"

n="$START"

while read -r first _ _ start _ end
 do
  if [[ "$first" = Chapter ]]
   then
      read  # discard line with Metadata:
      read _ _ chapter

      [[ "$n" -lt 10 ]] && partnum="0$n" || partnum="$n"
      echo "...Creating $title -- Part $partnum: $chapter.m4a"
      readarray -t ffoutput < <(ffmpeg -n -nostdin -hide_banner -stats -v error -vsync 2 -ss "${start%?}" -to "$end" -i "$1" -vn -codec copy "$outputdir/$title -- Part $partnum: $chapter.m4a" 2>&1)
      ((n++))
  fi
done <".tmp$stamp"

rm ".tmp$stamp"

shift
done
}
##m4bsplit{}##################################################################################

checkdur(){
  local m4a m4b opus
  m4a=(*m4a)
  m4b=(*m4b)
  opus=(*opus)

if [[ "$1" ]]
  then
      find -type f -iname "*.$1" -print0 | xargs -0 mplayer -vo dummy -ao dummy -identify 2>/dev/null | perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "%02d:%02d:%02d\n",$t/3600,$t/60%60,$t%60' | tail -n 1
  else
    printf '\n%sDuration(s):%s\n' "$bold" "$tput0"
    [[ "${#m4a[@]}" -gt 0 ]] &&
      printf '%s %s%s%s %s%s\n' "$bold" "$red" "$(    find -type f -iname "*.m4a" -print0 | xargs -0 mplayer -vo dummy -ao dummy -identify 2>/dev/null | perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "%02d:%02d:%02d\n",$t/3600,$t/60%60,$t%60' | tail -n 1)" "$white"  "${m4a[@]}" "$tput0"
    [[ "${#m4b[@]}" -gt 0 ]] &&
      printf '%s %s%s%s %s%s\n' "$bold" "$red" "$(    find -type f -iname "*.m4b" -print0 | xargs -0 mplayer -vo dummy -ao dummy -identify 2>/dev/null | perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "%02d:%02d:%02d\n",$t/3600,$t/60%60,$t%60' | tail -n 1)" "$white" "${m4b[@]}" "$tput0"
    [[ "${#opus[@]}" -gt 0 ]] &&
      printf '%s %s%s%s %s%s\n' "$bold" "$red" "$(    find -type f -iname "*.opus" -print0 | xargs -0 mplayer -vo dummy -ao dummy -identify 2>/dev/null | perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "%02d:%02d:%02d\n",$t/3600,$t/60%60,$t%60' | tail -n 1)" "$white" "${opus[@]}" "$tput0"
 fi
}
##checkdur()##################################################################################

rmyn(){
  while true
  read -rp "$1"$'\n ' rmyn
   do
     case "$rmyn" in
       [yY] ) "${@:3}"; break;;
       [nN] ) printf '%s\n' "$2"; break;;
          * ) printf "Invalid response...\n";;
     esac
   done
}
##rmyn()######################################################################################



##start#######################################################################################

[[ "$1" == @(edit|e|nano) ]] && editscript

[[ "$1" == "-y" ]] && shift && rmmatch=true

filecheck "$1" && [[ ! "$?" == 0 ]] && exit

allm4s=(*m4?)

printf '\nAll *m4?: \n'
printf ' %s%s%s\n' "$red" "${allm4s[@]}" "$white"
printf '\n'

mediainfo "$m4bin"

m4bindur="$(checkdur m4b)"

printf '\n%sStarting .m4bfile:%s\n' "$bold" "$tput0"
printf ' %s%s%s%s\n' "$bold" "$red" "$m4bin" "$tput0"
printf ' %s%s%s\n' "$red" "$bold" "$m4bindur" "$tput0"
printf '\n\n'

title="${m4bin% -- *}"
swd="$PWD"
convertdir="$CACHE/convert-$title"

[[ "$convertdir" == *\'* ]] && convertdir="${convertdir//\'}"  #check $convertdir for \'s and remove them

[[ ! -d "$convertdir" ]] && mkdir "$convertdir"

if [[ ! "$(mediainfo "$m4bin"|grep Menu)" =~ ^Menu ]]
  then
    qtcnt=1
    calculatetime "$m4bin"
    while [[ "$qtcnt" -lt 5 ]]
      do
       printf '%s: ' "$qtcnt"
       ffmpeg -n -nostdin -hide_banner -stats -v error -ss $(python -c "print(($qtcnt-1)*$divsec)") -to $(python -c "print($qtcnt*$divsec)") -i "$m4bin" -vn -acodec copy "$convertdir/${m4bin%% -- *} -- Part 0$qtcnt.m4a"
       ((qtcnt++))
     done
    cd "$convertdir"
    for i in First Second Third Fourth
      do
        ((n++))
        for f in *\ --\ Part\ 0"$n".*
          do
           mv "$f" "${f/./: $i Quarter.}"
          done
       done
  else
    m4bsplit "$m4bin" "$convertdir"
    cd "$convertdir"
    regexexp='.*\ --\ Part\ [[:digit:]]{2}:\ Chapter\ [[:digit:]][\ |\.]'
    for m4afile in *m4a
      do
        [[ "$m4afile" =~ .*\ --\ Part\ [[:digit:]]{2}:\ Chapter\ [[:digit:]][\.\ ] ]] &&
           mv "$m4afile" "${m4afile/Chapter /Chapter 0}"
      done
fi

cd "$convertdir"

printf '\n'
ls "$convertdir"
printf '\n'

[[ "$rmmatch" != true ]] && pause "${ulon}${red}Control-Z to suspend to change to $convertdir and adjust chapter names?${uloff}${white} "

printf '\n'
printf '%s\n----------  Calling external dependency: %sopus.book.4%s  ----------\n' "$bold" "$red" "$tput0"
opus.book.4  #this is a dependency; needs to be made a function?
printf '\n'
printf '%s\n----------  Leaving external dependency: %sopus.book.4%s  ----------\n' "$bold" "$red" "$tput0"
#opus.book.4##################################################################################




clear -x

#IFS=':'
#opuspartdur=$(find -type f -iname "*-- Part *.opus" -print0 2>/dev/null |
#          xargs -0 mplayer -vo dummy -ao dummy -identify 2>/dev/null |
#          perl -nle '/ID_LENGTH=([0-9\.]+)/ && ($t +=$1) && printf "%02d:%02d:%02d\n",$t/3600,$t/60%60,$t%60' |
#          tail -n 1)

[[ ! -d "$convertdir/m4a" ]] && mkdir "$convertdir/m4a"
mv *.m4a ./m4a
opuspartdur="$(checkdur opus)"
m4bindur="${m4bindur#*: }"

printf '\n\n%sDuration of the original m4b file: %s%s%s\n' "$bold" "$red" "$m4bindur" "$tput0"
printf '%sDuration of the .opus part files: %s%s%s\n' "$bold" "$red" "$opuspartdur" "$tput0"

printf '\n\n\n\n\n%s----------  Calling external dependency: %sindexopus%s  ----------\n' "$bold" "$red" "$tput0"
if [[ "$rmmatch" = true ]]
  then
# "$opuspartdur" is there realistically a way to pass the opus part durations?
    indexopus -y "$title" # "$opuspartdur" is there realistically a way to pass the opus part durations?
  else
    indexopus "$title" # this is a dependency, don't make a funciton.
fi

  [[ "$?" = 2 ]] && iorm=true

printf '\n\n%s----------  Leaving external dependency: %sindexopus%s  ----------\n' "$bold" "$red" "$tput0"
##indexopus##################################################################################




mv "$title -- Audiobook.opus" "$swd"
cd "$swd"

audiobook=( *\ --\ Audiobook.opus )
#echo "$rmmatch / m4b $(checkdur m4b) opus $(checkdur opus)"

#if [ ! -f *\ --\ Audiobook.opus ]  #this should be changed:
if [ ! -f *\ --\ Audiobook.opus ]  #this only works because there's exactly one *\ --\ Audiobook.opus
  then
    echo "No opus audiobook found! exit 1"
    exit 1
elif [[ "$rmmatch" = true ]] && [[ "$(checkdur m4b)" = "$(checkdur opus)" ]]
  then
    rm -r *m4b "$convertdir"
    printf '\n\n...Done.\n\nPlease see %s/%s\n\n' "$PWD" "$ioutput"
elif [[ "$rmmatch" = true ]] && [[ "$(checkdur m4b)" != "$(checkdur opus)" ]]
  then
    printf '%s%sThe m4b and opus audiobook durations do not match!\n' "$bold" "$red"
    printf '%s%sm4b2opus will not automatically delete starting and temporary files!\n' "$white" "$tput0"
    ls "$tmp" "$convertdir/m4a" 2>/dev/null
    checkdur
    printf '\n\n'
#    rmyn "Remove the conversion ../tmp and ../m4a directories? " "...Leaving ../tmp and ../m4a" rm -r "$convertdir"/tmp "$convertdir"/m4a
    rmyn "Remove the conversion ../tmp and ../m4a directories? " "...Leaving ../tmp and ../m4a" rm -r "$tmp" "$convertdir"/m4a
    [[ ! "$iorm" ]] && rmyn "Remove $ititle -- Part *.opus files? " "...Leaving $ititle -- Part *.opus files..." rm "$convertdir/$title"\ --\ Part\ ??:*.opus
    rmr *m4b "$convertdir"   #rmr is a dependency
    printf '\n\n...Done.\n\nPlease see %s/%s\n\n' "$PWD" "$ioutput"
else
    ls "$tmp" "$convertdir/m4a" 2>/dev/null
    checkdur
    printf '\n\n'
    rmyn "Remove the conversion ../tmp and ../m4a directories? " "...Leaving ../tmp and ../m4a" rm -r "$tmp" "$convertdir"/m4a
    [[ ! "$iorm" ]] && rmyn "Remove $ititle -- Part *.opus files? " "...Leaving $ititle -- Part *.opus files..." rm "$convertdir/$title"\ --\ Part\ ??:*.opus
    rmr *m4b "$convertdir"   #rmr is a dependency
    printf '\n\n...Done.\n\nPlease see %s/%s\n\n' "$PWD" "$ioutput"
fi
