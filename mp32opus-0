#!/bin/bash

## definitions #################################################################################
shopt -s nullglob
[[ "$TERM" = screen ]] && TERM=screen.xterm-256color
[[ "$TERM" = dummy ]] && TERM=xterm-256color
export TERM

tput0="$(tput sgr0)"
white="$(tput setaf 15)"
boldred="$(tput bold setaf 9)"
red="$(tput setaf 1)"
relipsis="${red}..."
#rmmatch=1

## source functions #################################################################################
. /usr/local/bin/editscript
sourcefn -l /usr/local/bin/indexopus.lib -f sex2sec -f printline -f confirm

args=(mp32opus)

while (( $# > 0 )); do
  [[ "$1" = @(edit|e|nano) ]] && editscript && exit
  [[ "$1" = @(--screen|-s) ]] && shift && screened=1 && continue
  [[ "$1" = "-y"           ]] && args+=("$1") && shift && rmmatch=1 && continue
  [[ "$1" = "-n"           ]] && args+=("$1") && shift && no=1 && unset rmmatch && continue
  [[ "$1" = "--stats"      ]] && args+=("$1") && shift && stats=true && initargs=("$1") && continue
  [[ "$1" = @(-ys|-yes)    ]] && args+=("-y") && shift && rmmatch=1 && screened=1 && continue
  [[ "$1" = @(-D|--discord) ]] && { args+=("$1"); shift; discord=1; . ~/.config/apprise.conf; continue; }
#  [[ -e "$1" ]] && args+=("$1") && shift && clipath="$1" && continue
  [[ -d "$1" ]] && args+=("$1") && shift && clidir="$1" && continue
  [[ -f "$1" ]] && args+=("$1") && shift && clifile="$1" && continue
  { printf '%s is unrecognized.\n' "$1"; shift; confirm -y 'Proceed with script?' || exit 1; }
done

## this should work for "." as well as set the script up for the screen call below.
## this shouldn't need to be before screen...it can happen after screen is invoked.
[[ "$clidir" ]] && clidir="$(realpath clidir)" && [[ "$(pwd)" != "$clidir" ]] && cd "$clidir"

if (( screened )); then
  printline "$bold Calling ${args[@]} in GNU screen $tput0"
  printf \\n\\n
  allm4s=(*.m4[ab])

## this needs to be fixed:

  screenname="mp32opus-${PWD##*/}"
  ! (( no )) && args+=(-y)
  printf '%s ' "${args[@]}"
  printf \\n
  screen -dmS "${screenname:0:16}" "${args[@]}"
  screen -ls                                     #could probably add some logic to not delete shit
  printf \\n\\n                                  #leaving that for later, but screen implies -y as
  exit                                           #it doesn't really work otherwise?
fi

[[ "$rmmatch" ]] && args=( -y )                  #this resets args from "$@"
printline "$bold  Welcome to ${0##*\/}  $tput0"
printf \\n
printline "$bold  $(pwd):  $tput0"
eza -l --no-user
printf \\n
printline "${bold}  Calling ${white}opus.book.4  ${tput0}"
clear -x
opus.book.4 || { ec="$?"; printf 'An error was returned by opus.book.4; exit code %s. Investigate. (exit %s)\n' "$ec" "$ec"; exit "$?"; }
printline "${bold}  Calling ${white}indexopus ${args[@]} ${tput0}"
indexopus "${args[@]}"
#readarray -t durations < <(mediaduration|sed 's/^[^:]*: //')
printf \\n
printline "${bold}  ${white}Checking durations  ${tput0}"
printf \\n
readarray -t durations < <(mediaduration)
printf %s\\n "${durations[@]}"
(( "${#durations[@]}" != 2 )) && { printf 'There are more than two different formates reported by mediaduration and automatic deletion cannot proceed. Investigate.\n'; confirm "Continue?"; rmmatch=0; }

[[ "${durations[-1]}" != Duration\ of\ .opus\ files* ]] && noopus=1

if (( noopus )); then
  for ((i=0; i<"${#durations[@]}"; i++)); do
    [[ "${durations[$i]}" = Duration\ of\ .opus\ files* ]] && opuskey=1 && noopus=0
    break
  done
  (( noopus )) &&
    { printf 'There was no opus duration found by mediaduration. Investigate. (exit 1)';
      exit 1; }
fi

sourceext="${durations[0]% files*}"; sourceext="${sourceext#*of }"
sourcedur="${durations[0]#*: }"
opusdur="${durations[${opuskey:--1}]#*: }"

opusdursec="$(sex2sec "$opusdur")"
sourcedursec="$(sex2sec "$sourcedur")"



title=(*\ --\ Audiobook.opus)
(( "${#title[@]}" == 1 )) && title="${title% -- Audiobook.opus}"
ioutput="$(tput sitm)$title$(tput ritm) -- Audiobook.opus"

if (( opusdursec > 0 )); then
  verifydur=$(( (1000 * (sourcedursec - opusdursec)) / opusdursec ))
  verifydur=$(( verifydur < 0 ? -verifydur:verifydur ))

printf \\n

  if (( verifydur <= 1 )); then  #this is 0.1% difference
    { (( rmmatch )) || confirm -y "Durations are within 0.1%.\n  $(ls *mp3) \n\nRemove starting mp3 files?"; } && rm *.mp3
    [[ "$sourcedursec" != "$opusdursec" ]] &&
       printf '\n%sDurations don'\''t %sexactly%s match but fuckin'\'' close '\''nuff!%s\n' "$relipsis" "$(tput sitm)" "$(tput ritm)" "$tput0" ||
       printf '%sDurations match!%s\n' "$relipsis" "$tput0"
    printf '\n%sDone.\n\nPlease see %s/%s%s\n\n' "$relipsis" "$(pwd)" "$ioutput" "$tput0"
    (( discord )) && apprise "$apprisediscord" -t "mp32opus completed:" -b "$title"
    exit
  elif (( rmmatch )) && (( verifydur )); then
    printf '%s%sThe source and opus audiobook durations do not match!\n' "$bold" "$red"
    printf '%s%s%s will not automatically delete starting and temporary files!\n' "$white" "$tput0" "$0"
    printf '\n\n'
    printf '%s-y/-f specified, but the durations do not match!\nThe files have been left for later deletion.\n%s' "$boldred" "$tput0"
  elif (( verifydur > 1 )); then
    pctdif="$(printf '%d.%d\n' $((verifydur / 10)) $((verifydur % 10)))"
    printf '%sThe difference between the source %s files and the .opus files of %s%% is greater than 0.1%%!\n%s' "$red" "$sourceext" "$pctdif" "$tput0"
    confirm "Would you like to delete the starting $sourceext files?" && rm *"$sourceext"
  fi

elif (( opusdursec = 0 )); then
  printf 'The duration of the opus files [in seconds] is zero and would present a divide by zero error. Investigate.\n(exit 1)\n.'
  exit 1
fi


(( discord )) && apprise "$apprisediscord" -t "m4b2opus completed:" -b "$title"
