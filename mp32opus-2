#!/bin/bash

## definitions #################################################################################
shopt -s nullglob extglob
[[ "$TERM" = screen ]] && TERM=screen.xterm-256color
[[ "$TERM" = dummy ]] && TERM=xterm-256color
export TERM

tput0="$(tput sgr0)"
white="$(tput setaf 15)"
boldred="$(tput bold setaf 9)"
red="$(tput setaf 1)"
relipsis="${red}..."
tmpdir=/cache
discord=1
calltmpf="/tmp/mp32opus-calltmpf-$(date -Im).tmp"  ## temp file to communicate with called scripts
#rmmatch=1

## source functions #################################################################################
. /usr/local/bin/editscript
sourcefn -l /usr/local/bin/indexopus.lib -f sex2sec -f printline -f confirm


## functions ########################################################################################

##there's another filecheck() below
filecheck(){
(( verbose )) && printf '[verbose] Entering filecheck().\n'
  local clifilepath clifilename clifiledir clipath mvoutput mvec  ## not sure what to do here.  need to see the scope of these variables.
  if [[ ! "$1" ]]; then
    allfiles=(*mp3)
   (( "${#allfiles[@]}" != 1 )) && { printf '${#allfiles[@]} != 1\n'; exit 1; }
   set -- "$allfiles"
  fi

  [[ -e "$1" ]] && clifilepath="$(realpath "$1")"  #if a filename is passed via the cli.  this doesn't work anymore now with -t??
read -rp "\$clifilepath is $clifilepath"


(( verbose )) && read -rp "[verbose] \$clifilepath: ${clifilepath:-null}"
  [[ -d "$clifilepath" ]] && clipath="${clifilepath%/}" && cd "$clipath" && unset clifilepath
  [[ -f "$clifilepath" ]] && clipath="${clifilepath%/*}" && cd "$clipath" && clifilepath="${clifilepath##*/}" ## add an || unset clifilepath here?
(( verbose )) && read -rp "[verbose] \$clifilepath: ${clifilepath:-null}"
(( verbose )) && read -rp "[verbose] \$clipath: ${clipath:-null}"

#  if [[ "$clipath" ]]; then
#    [[ -d "$clipath" && ! -w "$clipath" ]] && { own "$clipath" || { printf 'Cannot take ownership of %s. Investigate. (exit 1)' "$clipath"; exit 1; }; }

  if ! [[ -w . ]]; then
    printf '\n[WARN] The pwd\n(%s)\n is not writable; attempting to take ownership.\n\n' "$(pwd)"

    (( verbose )) && pause "[verbose] $(type own) $(which own)"

    (( rmmatch )) && { own --force .; :; } || own .

    if ! [[ -w . ]]; then
      (( verbose )) && printf '\n[WARN] The `own .` command failed\n\nTrying `sudo chown $USER .`\n\n' &&
      eza -glaa .
      if ! sudo -n chown -R "$USER":"${group:-$USER}" .; then
        (( verbose )) && printf '[WARN] The `sudo -n chown -R "%s":"%s" .` command failed!\n' "$USER" "${group:-$USER}"
        (( discord )) && discorddm "mp32opus: Attention required! confirm \`sudo chown \"$USER\" .\`"
        sudo chown -R "$USER":"${group:-$USER}" . || { printf '[ERROR] Cannot take ownership of %s. Investigate. (exit 1)\n' "$clipath"; exit 1; }
      fi
    fi
    ! [[ -w . ]] && { printf '[ERROR] Cannot take ownership of %s. Investigate. (exit 1)\n' "$clipath"; exit 1; } || printf '\nOwnership of pwd granted to %s.\n' "$USER"
  fi

##  [[ "$clifilename" = *\ --\ Audiobook.m4b ]] && [[ -f "$1" ]] && m4bin="$1" && return 0
#  [[ "$clifilename" = *\ --\ Audiobook.m4b ]] && [[ -f "$clifilename" ]] && { m4bin="$clifilename"; return 0; }
#
### at this point the pwd should either be the swd or it should be the local "$clipath" from the cd "$clipath" above.
#(( verbose )) && read -rp "[verbose] \$(pwd): $(pwd)"
#
#  [[ "$clifilename" ]] && files=("$clifilename") || files=(*.m4[ba])
#
#(( verbose )) && read -rp "[verbose] \${files[@]}: $(printf %s\\n "${files[@]}")"
#
#    if (( "${#files[@]}" == 1 )); then
#
#      # to handle the case where there's an unindexed m4a or a misnamed m4b,
#      # for simplicity sake, just rename to m4b
#      # probably want to change it back at the end, but it is going to get deleted anyway
#      if [[ "${files[0]}" = *.m4a ]]; then
#        startm4a="${files[0]}"
#        startfile="$startm4a"
#        files[0]="${files[0]%.m4a}.m4b"
#        mv "$startm4a" "${files[0]}"
#        (( "$?" )) && { printf 'The starting file was an m4a which could not be renamed to m4b:\n mv %s %s\nInvestigate. (return 1)' "${startm4a@Q}" "${files[0]@Q}"; return 1; }
#      fi
#
#      if [[ "${files[0]}" = *\ --\ Audiobook.m4b ]]; then
#        m4bin="${files[0]}"
#      elif [[ "${files[0]}" = *.m4b ]]; then
#        m4bin="${files[0]}"
###        startfile="${files[0]}"
###   is there any reason I need to do this?
###   could I make this conditional on ! (( save ))?
###        m4bin="${files[0]/.m4b/ -- Audiobook.m4b}"
###        mvoutput="$(mv "${files[0]}" "$m4bin" 2>&1)"
#        mvec="$?"
#        if (( mvec > 0 )); then
#          if [[ "$mvoutput" = "mv: cannot move "*": Permission denied" ]]; then
#            own && mv "${files[0]}" "$m4bin" || { printf 'Unable to gain write permission for %s. exit 1\n\n' "${files[@]}"; exit 1; }
#          else
#            printf 'Unknown error renaming %s. exit 1\n\n' "${files[@]}"
#            exit 1
#          fi
#        fi
#      else
#        printf 'The file passed to the script was not an *m4[a|b]:\n %s\n.  This cannot be allowed to stand!\n\nInvestigate. (return 1)\n' "$1"
#        return 1
#      fi
#    else
#      printf 'No single m4b/m4a input file found or specified, please check and retry...\n\n'
#      eza -laa --no-user
#      printf '\n(exit 1)\n\n'
#      exit 1
#    fi

(( verbose )) && { printf '[verbose] Leaving filecheck():\n'; [[ "$clipath" || "$clifilepath" ]] && pause "          \$clipath/\$clifilepath: $clipath/$clifilepath"; }
#  fi
return 0
}
##--> filecheck() <--#################################################################################



filecheck(){
(( verbose )) && printf '[verbose] Entering %s().\n' "$FUNCNAME"
  local clifilepath clifile  clidir clipath mvoutput mvec writable unwritable ## not sure what to do here.  need to see the scope of these variables.
  if [[ ! "$1" ]]; then
    until (( writable )); do
      unwritable=0
      for i in "${allfiles[@]}"; do
        [[ ! -w "$i" ]] && { (( unwritable++ )); printf 'Found an unwritable file among ${allfiles[@]}: %s.\nbreak\n' "$i"; break; }
      done
      ! (( unwritable )) && { writable=1; set -- "$allfiles"; break; }
#      (( n > 2 )) && { printf 'Unable to own files in "${allfiles[@]}". Exiting %s (return 1).\n' "$FUNCNAME"; return 1; }
#      (( n )) && allfiles=( --force "${allfiles[@]}" )
       (( n )) && set -- "$allfiles" && break
      (( unwritable )) && { confirm -Y "Do you want to own all of these files:\n$(printf %s\\n "${allfiles[@]}")\nConfirm?" && group=media own "${allfiles[@]}" || return 1; }
      read -rp "$(which own)"
      (( n++ ))
    done
  fi


## This is more than a little problematic:

  (( "${#allfiles[@]}" )) && for i in "${allfiles[@]}"; do own "$i"; done


  [[ -e "$1" ]] && clifilepath="$(realpath "$1")"  #if a filename is passed via the cli.  this doesn't work anymore now with -t??

(( verbose )) && read -rp "[verbose] \$clifilepath is $clifilepath"


(( verbose )) && read -rp "[verbose] \$clifilepath: ${clifilepath:-null}"
  [[ -d "$clifilepath" ]] && clidir="$clifilepath" && cd "$clidir" && unset clifilepath
  [[ -f "$clifilepath" ]] && { clifile="$(basename "$clifilepath")"; clidir="$(dirname "$clifilepath")"; cd "$clidir" || exit 1; } ## add an || unset clifilepath here?
(( verbose )) && read -rp "[verbose] \$clifilepath: ${clifilepath:-null}"
(( verbose )) && read -rp "[verbose] \$clipath: ${clipath:-null}"
(( verbose )) && read -rp "[verbose] \$clidir: ${clidir:-null}"
(( verbose )) && read -rp "[verbose] \$clifile: ${clifile:-null}"

#  if [[ "$clipath" ]]; then
#    [[ -d "$clipath" && ! -w "$clipath" ]] && { own "$clipath" || { printf 'Cannot take ownership of %s. Investigate. (exit 1)' "$clipath"; exit 1; }; }

  if ! [[ -w . ]]; then
    printf '\n[WARN] The pwd\n(%s)\n is not writable; attempting to take ownership.\n\n' "$(pwd)"

    (( verbose )) && pause "[verbose] $(type own) $(which own)"

    (( rmmatch )) && { own --force .; :; } || own .

    if ! [[ -w . ]]; then
      (( verbose )) && printf '\n[WARN] The `own .` command failed\n\nTrying `sudo chown $USER .`\n\n' &&
      eza -glaa .
      if ! sudo -n chown -R "$USER":"${group:-$USER}" .; then
        (( verbose )) && printf '[WARN] The `sudo -n chown -R "%s":"%s" .` command failed!\n' "$USER" "${group:-$USER}"
        (( discord )) && discorddm "mp32opus: Attention required! confirm \`sudo chown \"$USER\" .\`"
        sudo chown -R "$USER":"${group:-$USER}" . || { printf '[ERROR] Cannot take ownership of %s. Investigate. (exit 1)\n' "$clipath"; exit 1; }
      fi
    fi
    ! [[ -w . ]] && { printf '[ERROR] Cannot take ownership of %s. Investigate. (exit 1)\n' "$clipath"; exit 1; } || printf '\nOwnership of pwd granted to %s.\n' "$USER"
  fi


  [[ ! -w "$clifile" ]] && {
    (( discord )) && discorddm "mp32opus notification: ${clifile:-${allfiles[0]:-title unavailable}} not writeable.";
    printf 'mp32opus notification: %s not writeable.\n' "${clifile:-${allfiles[0]:-title unavailable}}"; }

 (( verbose )) && read -rp "Need to implement an own warn step here step here; continue..."



##  [[ "$clifilename" = *\ --\ Audiobook.m4b ]] && [[ -f "$1" ]] && m4bin="$1" && return 0
#  [[ "$clifilename" = *\ --\ Audiobook.m4b ]] && [[ -f "$clifilename" ]] && { m4bin="$clifilename"; return 0; }
#
### at this point the pwd should either be the swd or it should be the local "$clipath" from the cd "$clipath" above.
#(( verbose )) && read -rp "[verbose] \$(pwd): $(pwd)"
#
#  [[ "$clifilename" ]] && files=("$clifilename") || files=(*.m4[ba])
#
#(( verbose )) && read -rp "[verbose] \${files[@]}: $(printf %s\\n "${files[@]}")"
#
#    if (( "${#files[@]}" == 1 )); then
#
#      # to handle the case where there's an unindexed m4a or a misnamed m4b,
#      # for simplicity sake, just rename to m4b
#      # probably want to change it back at the end, but it is going to get deleted anyway
#      if [[ "${files[0]}" = *.m4a ]]; then
#        startm4a="${files[0]}"
#        startfile="$startm4a"
#        files[0]="${files[0]%.m4a}.m4b"
#        mv "$startm4a" "${files[0]}"
#        (( "$?" )) && { printf 'The starting file was an m4a which could not be renamed to m4b:\n mv %s %s\nInvestigate. (return 1)' "${startm4a@Q}" "${files[0]@Q}"; return 1; }
#      fi
#
#      if [[ "${files[0]}" = *\ --\ Audiobook.m4b ]]; then
#        m4bin="${files[0]}"
#      elif [[ "${files[0]}" = *.m4b ]]; then
#        m4bin="${files[0]}"
###        startfile="${files[0]}"
###   is there any reason I need to do this?
###   could I make this conditional on ! (( save ))?
###        m4bin="${files[0]/.m4b/ -- Audiobook.m4b}"
###        mvoutput="$(mv "${files[0]}" "$m4bin" 2>&1)"
#        mvec="$?"
#        if (( mvec > 0 )); then
#          if [[ "$mvoutput" = "mv: cannot move "*": Permission denied" ]]; then
#            own && mv "${files[0]}" "$m4bin" || { printf 'Unable to gain write permission for %s. exit 1\n\n' "${files[@]}"; exit 1; }
#          else
#            printf 'Unknown error renaming %s. exit 1\n\n' "${files[@]}"
#            exit 1
#          fi
#        fi
#      else
#        printf 'The file passed to the script was not an *m4[a|b]:\n %s\n.  This cannot be allowed to stand!\n\nInvestigate. (return 1)\n' "$1"
#        return 1
#      fi
#    else
#      printf 'No single m4b/m4a input file found or specified, please check and retry...\n\n'
#      eza -laa --no-user
#      printf '\n(exit 1)\n\n'
#      exit 1
#    fi

  printf 'Leaving %s()\n' "$FUNCNAME"
(( verbose )) && { printf '[verbose] Leaving filecheck():\n'; [[ "$clidir" || "$clifile" ]] && pause "          \$clidir/\$clifile: $clidir/$clifile"; }
#  fi
return 0
}
##--> filecheck() <--#################################################################################


extractcover(){
  local file="$1"
  if mediainfo "$1"|grep -A1 '^Image'|grep -qE '^Type\s+:\s+Cover';  then
    coverfile="${file%.*} -- Cover.jpg"
    (( verbose )) &&
     { printf 'Source file = %s\n' "$file"
       printf ' Cover file = %s\n' "$coverfile"
       printf '\nMediaInfo of source file:\n'
       readarray -t miout < <(mediainfo "$file")
       printf '     %s\n' "${miout[@]}"; }
    (( verbose )) && read -rp "$file $coverfile"
    ffmpegcmd=( ffmpeg -i "$file" -an -update 1 -frames:v 1 "file:$coverfile" -y )
    if [[ -f "$coverfile" ]]; then
      if (( rmmatch )) || [[ "$STY" ]]; then
        mv "$coverfile" "$coverfile~"
        ffmpegcmd+=(-y)  ## probably unnecessary, but do not want to hold up screened process
        printf 'File %1$s exists. Moving to %1$s~ and extracting cover.\n' "$coverfile"
      else
        (( verbose )) &&
         { printf 'MediaInfo of existing cover file:\n' "$coverfile"; readarray -t miout < <(mediainfo "$coverfile"); printf '     %s\n' "${miout[@]}"; }
        confirm "$(printf 'Overwrite existing cover file?' "$coverfile")" && ffmpegcmd+=(-y) ||
          printf 'Not overwriting existing cover file. (return 1)'
      fi
    fi

    (( verbose )) && printf 'ffmpeg call: %s\n' "${ffmpegcmd[*]}"

    if (( verbose )); then "${ffmpegcmd[@]}"
    else "${ffmpegcmd[@]}" &> /dev/null; fi

    ec="$?"

    (( verbose )) && { readarray -t miout < <(mediainfo "$coverfile"); printf '     %s\n' "${miout[@]}"; }
    printf %s\\n "$coverfile"
  else
    printf 'No embedded cover found in: %s\n' "$file" >&2
    return 1
  fi
}

##--> extractcover() <--##############################################################################


## main code###### ###################################################################################


## flag processing ###################################################################################

args=(mp32opus)

while (( $# > 0 )); do
  [[ "$1" =         "--edit" ]] && editscript && exit
  [[ "$1" =             "-y" ]] && { args+=("$1"); args+=(--save); (( save=rmmatch=1 )); shift; continue; }
  [[ "$1" =             "-Y" ]] && { args+=("$1"); rmmatch=1; shift; continue; }
  [[ "$1" =             "-n" ]] && { args+=("$1"); no=1; unset rmmatch; shift; continue; }
  [[ "$1" =         "--save" ]] && { args+=("$1"); save=1; shift; continue; }
  [[ "$1" =        "--stats" ]] && { args+=("$1"); stats=1; shift; continue; }
  [[ "$1" =   @(--screen|-s) ]] && { screened=1; shift; continue; }
  [[ "$1" = @(-|--)@(ys|yes) ]] && { args+=("-y"); (( screened=rmmatch=1 )); args+=(--save); shift; continue; }
  [[ "$1" = @(-|--)@(Ys|Yes) ]] && { args+=("-Y"); (( screened=rmmatch=1 )); shift; continue; }
  [[ "$1" =  @(-v|--verbose) ]] && { args+=("$1"); verbose=1; shift; continue; }
  [[ "$1" =  @(-D|--discord) ]] && { args+=("$1"); unset discord; . ~/.config/discord-local.conf; shift; continue; }
  [[ -d "$1" ]] && { args+=("$1"); clipath="$1"; clidir="$1"; shift; continue; }
  [[ -f "$1" ]] && { args+=("$1"); clipath="$1"; clifile="$1"; shift; continue; }
  { printf '"%s" is unrecognized.\n' "$1"; shift; confirm -y 'Proceed with script?' || exit 1; }
done


[[ ! "$clifile" ]] && { allm4s=( *.m4[ab] ); allmp3=( *.mp3 )
                        allfiles=( "${allmp3[@]}" ); allfiles+=( "${allm4s[@]}" )
                        printf '\n%s/*.m4[ab]: \n\n%s' "$(pwd)" "$red"
                        printf ' %s\n' "${allm4s[@]:-No .m4[ab] files found!}"
                        printf '%s\n%s/*.mp3: \n\n%s' "$white" "$(pwd)" "$red"
                        printf ' %s\n' "${allmp3[@]:-No .mp3 files found!}"
                        printf '\n%s' "$white"; }

filecheck "${clipath:-""}"
(( "$?" )) && { printf 'The files failed filecheck()!\nInvestigate (exit 1)\n.'; exit 1; }

printline "$bold  Welcome to ${0##*\/}  $tput0"
printf \\n

if (( screened )); then
  printline "$bold Calling ${args[*]} in GNU screen $tput0"
  printf \\n\\n

  if (( verbose )) && { confirm -y "$0 was called to screen with verbose on.\nThis may result in stops in the script while in screen.\nTurn verbose off?"; printf \\n\\n; }; then
     for i in "${!args[@]}"; do
       [[ "${args[i]}" = '-v' ]] && unset 'args[i]'
     done
     args=("${args[@]}")       ## compact array
  fi

## this needs to be checked:
  [[ "$clipath" ]] && screenname="mp32opus-$(basename "$clipath")" ||
    screenname="mp32opus-${PWD##*/}"
  ! (( no )) && [[ " ${args[*]} " != *\ -Y\ * ]] && args+=("-y")
  printf '%s ' "${args[@]}"
  printf \\n
#  screen -dmS "${screenname:0:16}" "${args[@]}"
#  screen -dmS "${screenname:0:16}" bash -i -c "$(printf '%q ' "${args[@]}")"
  screen -dmS "${screenname:0:16}" bash -i "${args[@]}"
  screen -ls                                     #could probably add some logic to not delete shit
  printf \\n\\n                                  #leaving that for later, but screen implies -y as
  exit                                           #it doesn't really work otherwise?
fi

allm4s=(*.m4[ab])
allmp3s=(*.mp3)
allfiles=(*.@(mp3|m4@(a|b)))
## this should work for "." as well as set the script up for the screen call below.
## this shouldn't need to be before screen...it can happen after screen is invoked.

[[ "$clidir" ]] && clidir="$(realpath "$clidir")" && [[ "$(pwd)" != "$clidir" ]] && cd "$clidir"

[[ "$rmmatch" ]] && args=("-y") || unset args  #this resets args from "$@"

if [[ "$clifile" ]] || (( "${#allfiles[@]}" == 1 )); then
  [[ ! -w "$allfiles" ]] && (( discord )) && discorddm "mp32opus notification: ${title:-${allfiles[0]:-title unavailable}} not writeable."

  (( save )) && args+=(--save)
  (( verbose )) && args+=(-v)
  args+=(-D) ## unset the discord flag since this should be doing the notification.
  [[ "$calltmpf" ]] && touch "$calltmpf" && args+=( '--calling-tmp' "$calltmpf" )
  [[ "$clifile" ]] && { clifilerp="$(realpath "$clifile")"; args+=( "$clifilerp" ); }
  (( verbose )) &&  pause "$(printf '[verbose] mp32opus calling quartero4 %s\n' "${args[*]}")"
  printline "${bold}  Calling ${white}quartero4 ${args[@]}  ${tput0}"
  quartero4 "${args[@]}"
#  "${args[@]}"
  ec="$?"
  if (( ec )); then
    printf '[ERROR] quartero4 %s did not exit cleanly. Investigate. (exit %s)\n' "${args[*]}" "$ec"
    exit "$ec"
  else
    printf \\n
    printline "${bold}  Returned from ${white}quartero4 (exit $ec)  ${tput0}"
    printf \\n
  fi
else
  printline "$bold  $(pwd):  $tput0"
  eza -l --no-user
  printf \\n
  printline "${bold}  Calling ${white}opus.book.4 ${args[@]}  ${tput0}"
  clear -x
  readarray -t initdurations < <(mediaduration --durations)
  printf %s\\n "${initdurations[@]}"

## this check is a false sense of security as there's no way at present to check if there's not more than
## one book in the same format

  (( "${#initdurations[@]}" != 1 )) &&
   { printf 'There are more than two different formates reported by mediaduration and automatic deletion cannot proceed. Investigate.\n';
     confirm "Continue?" || exit 130; rmmatch=0; }

  (( "${#initdurations[@]}" == 1 )) && ext="${initdurations[0]#*.}" && ext="${ext%% *}"

  tmpdir="$tmpdir/mp32opus-${PWD##*/}"

  opus.book.4 --tmp "$tmpdir" || { ec="$?"; printf 'An error was returned by opus.book.4; exit code %s. Investigate. (exit %s)\n' "$ec" "$ec"; exit "$?"; }

  printline "${bold}  Calling ${white}indexopus ${args[*]} ${tput0}"


##  This is yet to be implemented in opus.book.4...
##  i.e., it needs to send the transcoded files to "$tmp" before cd there.
  swd="$(pwd)"

  { mkdir -p "$tmpdir" && cd "$tmpdir"; } || { printf 'Failure of `mkdir/cd %s` occurred! Investigate. (exit 1)\n' "$tmpdir"; exit 1; }

  eza -gla --no-user
  (( verbose )) && args+=('-v')
  (( verbose )) && pause "\$args=$(printf %s\\n "${args[@]}")"
  (( verbose )) && pause "pwd=$PWD"
  indexopus "${args[@]}"
  ec="$?"
  (( ec )) && (( ec == 1 )) && { printf '\nThe indexopus script did not exit cleanly. Investigate. (exit %s)\n\n' "$ec"; exit "$ec"; } # i don't know for sure that the ec from indexopus can\'t be other than 0, 1, 2.
  (( ec == 2 )) && iorm=true # this is something that is part of the m4b2opus integration with indexopus.  iorm *probably* means "indexopus rm" such that the user's said yes to a prompt to remove shit.

#readarray -t durations < <(mediaduration|sed 's/^[^:]*: //')

  [[ "$tmpdir" ]] && mv *\ --\ Audiobook.opus "$swd"

  printf \\n

  tmpdirfiles=(*)
  ## the tmpdir should have been emptied already...try to remove it now if so...
  if (( "${#tmpdirfiles[@]}" )); then
    eza -gla --no-user --color=always "$tmpdir"
    printf \\n
    confirm "The temp directory ($tmpdir) is not empty! Remove anyway?" && rmdir "$tmpdir"
  else
    rmdir "$tmpdir"
  fi


## This is yet to be implemented in opus.book.4 as above...
  cd "$swd" >/dev/null || { printf 'Failure to return to SWD after indexopus! Investigate. (exit 1)\n'; exit 1; }

  (( verbose )) && printf 'The $(pwd) is: %s\n' "$(pwd)"

  printline "${bold}  ${white}Checking durations  ${tput0}"
  printf \\n
  readarray -t durations < <(mediaduration)
  printf %s\\n "${durations[@]}"

  (( "${#durations[@]}" != 2 )) && { printf 'There are not exactly two different formats reported by mediaduration and automatic deletion cannot proceed. Investigate.\n'; confirm "Continue?"; rmmatch=0; }

  [[ "${durations[-1]}" != Duration\ of\ .opus\ files* ]] && noopus=1

  if (( noopus )); then
    for ((i=0; i<"${#durations[@]}"; i++)); do
      [[ "${durations[$i]}" = Duration\ of\ .opus\ files* ]] && opuskey="$i" && noopus=0 &&
      break
    done
    (( noopus )) &&
      { printf 'There was no opus duration found by mediaduration. Investigate. (exit 1)\n\n';
        exit 1; }
  fi

  sourceext="${durations[0]% files*}"; sourceext="${sourceext#*of }"
#  sourcedur="${durations[0]#*: }"
  sourcedur="${durations[0]##* }"
#  opusdur="${durations[${opuskey:--1}]#*: }"
  opusdur="${durations[${opuskey:--1}]##* }"

  (( verbose )) && pause "$(printf '[verbose] $sourcedur="%s"\n[verbose] $opusdur="%s"\n' "$sourcedur" "$opusdur")"


  opusdursec="$(sex2sec "$opusdur")"
  sourcedursec="$(sex2sec "$sourcedur")"


  title=(*\ --\ Audiobook.opus)
  (( "${#title[@]}" == 1 )) && title="${title% -- Audiobook.opus}"
  ioutput="$(tput sitm)$title$(tput ritm) -- Audiobook.opus"
  (( verbose )) && read -rp "$(printf '[verbose] title: %s\n' "$title")"

  if (( opusdursec > 0 )); then
    verifydur=$(( (1000 * (sourcedursec - opusdursec)) / opusdursec ))
    verifydur=$(( verifydur < 0 ? -verifydur:verifydur ))

    printf \\n

    if (( verifydur <= 1 )); then  #this is 0.1% difference
      { (( rmmatch )) || confirm -y "Durations are within 0.1%.\n$(ls *$ext) \n\nRemove starting $ext files?"; } && ! (( save )) && { rm -vf *."$ext"; rmdir "$tmpdir"; }
      [[ "$sourcedursec" != "$opusdursec" ]] &&
         printf '\n%sDurations don'\''t %sexactly%s match but fuckin'\'' close '\''nuff!%s\n' "$relipsis" "$(tput sitm)" "$(tput ritm)" "$tput0" ||
         printf '%sDurations match!%s\n' "$relipsis" "$tput0"
      printf '\n%sDone.\n\nPlease see %s/%s%s\n\n' "$relipsis" "$(pwd)" "$ioutput" "$tput0"
#      (( discord )) && apprise "$apprisediscord" -t "$(basename "$0") completed:" -b "${title:-title unavailable}"
     (( discord )) && discorddm "mp32opus completed: ${title:-title unavailable}"
     exit
    elif (( rmmatch )) && (( verifydur )); then
      printf '%s%sThe source and opus audiobook durations do not match!\n' "$bold" "$red"
      printf '%s%s%s will not automatically delete starting and temporary files!\n' "$white" "$tput0" "$0"
      printf '\n\n'
      printf '%s-y/-f specified, but the durations do not match!\nThe files have been left for later deletion.\n%s' "$boldred" "$tput0"
    elif (( verifydur > 1 )); then
      pctdif="$(printf '%d.%d\n' $((verifydur / 10)) $((verifydur % 10)))"
      printf '%sThe difference between the source %s files and the .opus files of %s%% is greater than 0.1%%!\n%s' "$red" "$sourceext" "$pctdif" "$tput0"
      confirm "Would you like to delete the starting $sourceext files?" && { rm *"$sourceext"; rmdir "$tmpdir"; }
    fi

  elif (( opusdursec = 0 )); then
    printf 'The duration of the opus files [in seconds] is zero and would present a divide by zero error. Investigate.\n(exit 1)\n.'
   (( discord )) && discorddm "mp32opus completed: $(printf 'The duration of the opus files [in seconds] is zero and would present a divide by zero error. Investigate.\n(exit 1)\n.')"
    exit 1
  fi
fi

if [[ -f "$calltmpf" ]]; then
  . "$calltmpf"
  [[ "$titleopus" ]] && title="$titleopus"
  (( verbose )) && printf '\ncat %s:\n%s\n\n' "$calltmpf" "$(cat "$calltmpf")"
  (( verbose )) && printf '$title=%s\n' "$title"
  rm "$calltmpf"
fi

#(( discord )) && apprise "$apprisediscord" -t "$(basename "$0") completed:" -b "${title:-title unavailable}"

(( discord )) && discorddm "mp32opus completed: ${title:-${clifile:-${allfiles[0]:-title unavailable}}}"

